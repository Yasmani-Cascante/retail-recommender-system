# tests/load/locust_comprehensive.py
"""
üéØ COMPREHENSIVE LOAD TESTING SCRIPT
====================================

Script de load testing completo que simula el comportamiento real de usuarios
en un sistema de recomendaciones para retail.

Autor: Arquitecto Senior & Load Testing Expert
Versi√≥n: 2.0 - Comprehensive Coverage
Fecha: Agosto 2025

üè™ SIMULACI√ìN REALISTA DE E-COMMERCE:
Este script simula diferentes tipos de usuarios en una tienda online:
- Browsing users: Navegan productos, ven recomendaciones
- Active shoppers: Buscan productos espec√≠ficos, ven detalles
- Engaged users: Usan chat conversacional, requieren personalizaci√≥n
- System monitors: Health checks de infraestructura
"""

import random
import json
import time
from locust import HttpUser, task, between, events
from typing import Dict, List

# üé® CONFIGURACI√ìN DE SIMULACI√ìN
class EcommerceConfig:
    """Configuraci√≥n realista para simular tr√°fico de e-commerce"""
    
    # Productos de muestra para testing
    SAMPLE_PRODUCT_IDS = [
        "product_001", "product_002", "product_003", "product_004", "product_005",
        "product_006", "product_007", "product_008", "product_009", "product_010"
    ]
    
    # Queries realistas para b√∫squeda
    SAMPLE_QUERIES = [
        "running shoes", "wireless headphones", "coffee machine", "laptop bag",
        "yoga mat", "smartphone case", "bluetooth speaker", "winter jacket",
        "desk chair", "water bottle", "gaming mouse", "reading glasses"
    ]
    
    # Conversaciones realistas para MCP
    CONVERSATION_QUERIES = [
        "I need something for my morning workout",
        "Looking for a gift for my tech-savvy friend",
        "What's good for working from home?",
        "I want to upgrade my kitchen appliances",
        "Need something for outdoor activities",
        "Looking for professional work accessories",
        "What's trending in electronics?",
        "I need comfortable clothing for travel"
    ]
    
    # Mercados soportados
    MARKETS = ["US", "ES", "MX"]
    
    # Event types para Google Cloud Retail API
    EVENT_TYPES = [
        "detail-page-view",
        "add-to-cart", 
        "purchase-complete",
        "search",
        "page-view"
    ]

class RetailRecommenderUser(HttpUser):
    """
    üõçÔ∏è Usuario simulado de e-commerce que realiza acciones realistas
    """
    
    # Tiempo de espera entre acciones (simula lectura/pensamiento del usuario)
    wait_time = between(1, 4)
    
    def on_start(self):
        """Inicializaci√≥n del usuario simulado"""
        self.api_key = "2fed9999056fab6dac5654238f0cae1c"
        self.headers = {"X-API-Key": self.api_key, "Content-Type": "application/json"}
        
        # Crear perfil de usuario √∫nico
        self.user_id = f"load_user_{random.randint(1000, 9999)}"
        self.market_id = random.choice(EcommerceConfig.MARKETS)
        self.session_id = f"session_{int(time.time())}_{random.randint(100, 999)}"
        
        # Carrito de compras simulado
        self.cart_items = []
        self.viewed_products = []
        
        print(f"üÜî Usuario iniciado: {self.user_id} en mercado {self.market_id}")

    # ========================================================================
    # üè™ ENDPOINTS PRINCIPALES DEL SISTEMA (PESO ALTO)
    # ========================================================================

    @task(15)  # Tarea m√°s frecuente - n√∫cleo del negocio
    def conversational_recommendation(self):
        """
        ü§ñ Endpoint principal MCP - Conversaciones personalizadas
        Simula usuarios pidiendo recomendaciones a trav√©s de chat AI
        """
        query = random.choice(EcommerceConfig.CONVERSATION_QUERIES)
        
        payload = {
            "query": query,
            "user_id": self.user_id,
            "market_id": self.market_id,
            "session_id": self.session_id,
            "enable_optimization": True,
            "max_recommendations": random.randint(3, 8)
        }
        
        with self.client.post(
            "/v1/mcp/conversation/optimized",
            json=payload,
            headers=self.headers,
            catch_response=True,
            name="ü§ñ MCP Conversation"
        ) as response:
            if response.status_code == 200:
                try:
                    data = response.json()
                    recommendations = data.get('recommendations', [])
                    if len(recommendations) > 0:
                        # Simular que el usuario ve algunos productos recomendados
                        for rec in recommendations[:2]:  # Ver primeros 2
                            if 'id' in rec:
                                self.viewed_products.append(rec['id'])
                        response.success()
                    else:
                        response.failure("Empty recommendations")
                except json.JSONDecodeError:
                    response.failure("Invalid JSON response")
            elif response.status_code == 422:
                response.failure("Validation error - check payload structure")
            else:
                response.failure(f"HTTP {response.status_code}")

    @task(12)  # Segunda tarea m√°s importante
    def get_product_recommendations(self):
        """
        üõçÔ∏è Recomendaciones basadas en producto espec√≠fico
        Simula usuarios viendo productos relacionados
        """
        product_id = random.choice(EcommerceConfig.SAMPLE_PRODUCT_IDS)
        
        params = {
            "n": random.randint(4, 10),
            "exclude_seen": "true"
        }
        
        with self.client.get(
            f"/v1/recommendations/{product_id}",
            params=params,
            headers=self.headers,
            catch_response=True,
            name="üõçÔ∏è Product Recommendations"
        ) as response:
            if response.status_code == 200:
                try:
                    data = response.json()
                    if isinstance(data, list) and len(data) > 0:
                        # Agregar productos vistos
                        for product in data[:3]:
                            if isinstance(product, dict) and 'id' in product:
                                self.viewed_products.append(product['id'])
                        response.success()
                    elif isinstance(data, dict) and data.get('recommendations'):
                        response.success()
                    else:
                        response.failure("No recommendations returned")
                except json.JSONDecodeError:
                    response.failure("Invalid JSON response")
            elif response.status_code == 404:
                response.failure("Product not found")
            else:
                response.failure(f"HTTP {response.status_code}")

    @task(10)  # Navegaci√≥n de productos
    def browse_products(self):
        """
        üìã Listar productos con paginaci√≥n
        Simula usuarios navegando el cat√°logo
        """
        params = {
            "page": random.randint(1, 5),
            "page_size": random.randint(10, 50)
        }
        
        with self.client.get(
            "/v1/products/",
            params=params,
            headers=self.headers,
            catch_response=True,
            name="üìã Browse Products"
        ) as response:
            if response.status_code == 200:
                try:
                    data = response.json()
                    # Validar estructura de respuesta
                    if isinstance(data, dict):
                        products = data.get('products', data.get('items', []))
                    else:
                        products = data if isinstance(data, list) else []
                    
                    if len(products) > 0:
                        # Simular que usuario ve algunos productos
                        for product in products[:2]:
                            if isinstance(product, dict) and 'id' in product:
                                self.viewed_products.append(product['id'])
                        response.success()
                    else:
                        response.failure("No products returned")
                except json.JSONDecodeError:
                    response.failure("Invalid JSON response")
            else:
                response.failure(f"HTTP {response.status_code}")

    @task(8)  # Recomendaciones personalizadas
    def get_user_recommendations(self):
        """
        üë§ Recomendaciones personalizadas para usuario
        Simula recomendaciones basadas en historial del usuario
        """
        params = {
            "n": random.randint(5, 12),
            "exclude_seen": "true" if len(self.viewed_products) > 0 else "false"
        }
        
        with self.client.get(
            f"/v1/recommendations/user/{self.user_id}",
            params=params,
            headers=self.headers,
            catch_response=True,
            name="üë§ User Recommendations"
        ) as response:
            if response.status_code == 200:
                try:
                    data = response.json()
                    recommendations = data if isinstance(data, list) else data.get('recommendations', [])
                    if len(recommendations) > 0:
                        response.success()
                    else:
                        response.failure("No user recommendations")
                except json.JSONDecodeError:
                    response.failure("Invalid JSON response")
            else:
                response.failure(f"HTTP {response.status_code}")

    # ========================================================================
    # üîç ENDPOINTS DE B√öSQUEDA Y DESCUBRIMIENTO (PESO MEDIO)
    # ========================================================================

    @task(6)  # B√∫squeda de productos
    def search_products(self):
        """
        üîç B√∫squeda sem√°ntica de productos
        Simula usuarios buscando productos espec√≠ficos
        """
        query = random.choice(EcommerceConfig.SAMPLE_QUERIES)
        
        params = {
            "q": query,
            "limit": random.randint(5, 20)
        }
        
        with self.client.get(
            "/v1/products/search/",
            params=params,
            headers=self.headers,
            catch_response=True,
            name="üîç Product Search"
        ) as response:
            if response.status_code == 200:
                try:
                    data = response.json()
                    results = data if isinstance(data, list) else data.get('results', [])
                    if len(results) > 0:
                        # Usuario ve primeros resultados
                        for result in results[:2]:
                            if isinstance(result, dict) and 'id' in result:
                                self.viewed_products.append(result['id'])
                        response.success()
                    else:
                        response.failure("No search results")
                except json.JSONDecodeError:
                    response.failure("Invalid JSON response")
            else:
                response.failure(f"HTTP {response.status_code}")

    @task(4)  # Registro de eventos de usuario
    def register_user_event(self):
        """
        üìä Registro de eventos de usuario
        Simula tracking de comportamiento para mejorar recomendaciones
        """
        if not self.viewed_products:
            return  # No hay productos vistos para registrar eventos
            
        product_id = random.choice(self.viewed_products)
        event_type = random.choice(EcommerceConfig.EVENT_TYPES)
        
        # Construir payload seg√∫n tipo de evento
        payload = {
            "product_id": product_id,
            "event_type": event_type,
            "session_id": self.session_id
        }
        
        # Agregar campos espec√≠ficos seg√∫n evento
        if event_type == "purchase-complete":
            payload["purchase_amount"] = round(random.uniform(10.0, 500.0), 2)
            payload["currency"] = "USD" if self.market_id == "US" else "EUR"
        elif event_type == "search":
            payload["search_query"] = random.choice(EcommerceConfig.SAMPLE_QUERIES)
        
        with self.client.post(
            f"/v1/events/user/{self.user_id}",
            json=payload,
            headers=self.headers,
            catch_response=True,  
            name="üìä User Events"
        ) as response:
            if response.status_code in [200, 201]:
                response.success()
            else:
                response.failure(f"HTTP {response.status_code}")

    # ========================================================================
    # üìä ENDPOINTS DE MONITOREO Y M√âTRICAS (PESO BAJO)
    # ========================================================================

    @task(3)  # M√©tricas del sistema
    def get_system_metrics(self):
        """
        üìä M√©tricas de rendimiento del sistema
        Simula dashboards y monitoring consultando m√©tricas
        """
        with self.client.get(
            "/v1/metrics",
            headers=self.headers,
            catch_response=True,
            name="üìä System Metrics"
        ) as response:
            if response.status_code == 200:
                try:
                    data = response.json()
                    # Validar estructura b√°sica de m√©tricas
                    if isinstance(data, dict) and len(data) > 0:
                        response.success()
                    else:
                        response.failure("Empty metrics response")
                except json.JSONDecodeError:
                    response.failure("Invalid JSON response")
            else:
                response.failure(f"HTTP {response.status_code}")

    @task(2)  # Health check (infraestructura)
    def health_check(self):
        """
        ‚öïÔ∏è Health check del sistema
        Simula load balancers y monitoring tools verificando salud
        """
        with self.client.get(
            "/health",
            catch_response=True,
            name="‚öïÔ∏è Health Check"
        ) as response:
            if response.status_code == 200:
                try:
                    data = response.json()
                    # Verificar que health check tenga estructura v√°lida
                    if isinstance(data, dict) and 'status' in data:
                        if data['status'] in ['operational', 'healthy', 'ok']:
                            response.success()
                        else:
                            response.failure(f"Unhealthy status: {data['status']}")
                    else:
                        response.failure("Invalid health check structure")
                except json.JSONDecodeError:
                    response.failure("Invalid JSON response")
            else:
                response.failure(f"HTTP {response.status_code}")

    # ========================================================================
    # üéØ FLUJOS DE USUARIO REALISTAS (TAREAS COMBINADAS)
    # ========================================================================

    @task(1)  # Flujo completo de compra
    def complete_shopping_flow(self):
        """
        üõí Flujo completo de usuario: B√∫squeda ‚Üí Vista ‚Üí Recomendaciones ‚Üí Evento
        Simula el journey completo de un usuario comprando
        """
        # 1. Buscar producto
        search_query = random.choice(EcommerceConfig.SAMPLE_QUERIES)
        self.client.get(
            "/v1/products/search/",
            params={"q": search_query, "limit": 5},
            headers=self.headers,
            name="üîç Shopping Flow - Search"
        )
        
        # 2. Ver recomendaciones de producto
        product_id = random.choice(EcommerceConfig.SAMPLE_PRODUCT_IDS)
        self.client.get(
            f"/v1/recommendations/{product_id}",
            params={"n": 5},
            headers=self.headers,
            name="üõçÔ∏è Shopping Flow - Recommendations"
        )
        
        # 3. Registrar evento de vista
        self.client.post(
            f"/v1/events/user/{self.user_id}",
            json={
                "product_id": product_id,
                "event_type": "detail-page-view",
                "session_id": self.session_id
            },
            headers=self.headers,
            name="üìä Shopping Flow - Event"
        )

# ========================================================================
# üìä EVENT LISTENERS PARA M√âTRICAS AVANZADAS
# ========================================================================

@events.request.add_listener
def on_request(request_type, name, response_time, response_length, exception, context, **kwargs):
    """
    üìä Listener para capturar m√©tricas detalladas durante el test
    """
    if exception:
        print(f"‚ùå Error en {name}: {exception}")
    elif response_time > 2000:  # Alertar sobre requests lentos
        print(f"‚ö†Ô∏è Slow request detected: {name} took {response_time:.2f}ms")

@events.test_start.add_listener  
def on_test_start(environment, **kwargs):
    """üöÄ Mensaje de inicio del load test"""
    print("=" * 80)
    print("üöÄ INICIANDO LOAD TEST COMPREHENSIVO")
    print("üéØ Simulando tr√°fico realista de e-commerce")
    print("üìä Endpoints cubiertos:")
    print("   ‚Ä¢ MCP Conversations (ü§ñ)")
    print("   ‚Ä¢ Product Recommendations (üõçÔ∏è)")
    print("   ‚Ä¢ Product Browsing (üìã)")
    print("   ‚Ä¢ User Recommendations (üë§)")
    print("   ‚Ä¢ Product Search (üîç)")
    print("   ‚Ä¢ User Events (üìä)")
    print("   ‚Ä¢ System Metrics (üìä)")
    print("   ‚Ä¢ Health Checks (‚öïÔ∏è)")
    print("=" * 80)

@events.test_stop.add_listener
def on_test_stop(environment, **kwargs):
    """üèÅ Resumen final del load test"""
    print("=" * 80)
    print("üèÅ LOAD TEST COMPLETADO")
    print("üìä Revisa los resultados en el dashboard de Locust")
    print("üéØ Endpoints m√°s cr√≠ticos para analizar:")
    print("   1. ü§ñ MCP Conversation (n√∫cleo del negocio)")
    print("   2. üõçÔ∏è Product Recommendations (experiencia usuario)")
    print("   3. ‚öïÔ∏è Health Check (estabilidad infraestructura)")
    print("=" * 80)

# ========================================================================
# üéõÔ∏è CONFIGURACI√ìN AVANZADA (OPCIONAL)
# ========================================================================

class AdvancedEcommerceUser(RetailRecommenderUser):
    """
    üéì Usuario avanzado con patrones de comportamiento m√°s complejos
    Usar solo para tests de alta complejidad
    """
    
    # Usuarios avanzados son m√°s r√°pidos
    wait_time = between(0.5, 2)
    
    @task(1)
    def advanced_personalization_flow(self):
        """
        üß† Flujo avanzado que simula usuarios power con m√∫ltiples interacciones
        """
        # Conversaci√≥n personalizada con contexto
        conversation_payload = {
            "query": f"Based on my previous purchases, what would you recommend for {random.choice(['work', 'leisure', 'fitness', 'travel'])}?",
            "user_id": self.user_id,
            "market_id": self.market_id,
            "session_id": self.session_id,
            "enable_optimization": True,
            "context": {
                "previous_purchases": self.viewed_products[:3],
                "preferences": {
                    "price_range": random.choice(["budget", "mid", "premium"]),
                    "style": random.choice(["casual", "professional", "sporty"])
                }
            }
        }
        
        self.client.post(
            "/v1/mcp/conversation/optimized",
            json=conversation_payload,
            headers=self.headers,
            name="üß† Advanced Personalization"
        )
