# src/api/routers/products_router.py
"""
Products Router - Endpoints para gestiÃ³n de productos
====================================================

Router que maneja endpoints relacionados con productos,
incluyendo integraciÃ³n con sistema de inventario.

Author: Technical Team
Version: 1.0.0
"""

import logging
import time
from typing import Dict, List, Optional, Any
from fastapi import APIRouter, Depends, HTTPException, Query, Request
from pydantic import BaseModel, Field

# Imports del sistema
from src.api.security_auth import get_api_key
from src.api.core.store import get_shopify_client
from src.api.inventory.inventory_service import create_inventory_service, InventoryService
from src.api.inventory.availability_checker import create_availability_checker
from src.api.core.redis_client import RedisClient

logger = logging.getLogger(__name__)

# Modelos Pydantic para respuestas
class ProductResponse(BaseModel):
    """Modelo de respuesta para productos individuales"""
    id: str
    title: str
    description: Optional[str] = None
    price: Optional[float] = None
    currency: str = "USD"
    image_url: Optional[str] = None
    category: Optional[str] = None
    
    # Campos de inventario
    availability: str = "available"
    in_stock: bool = True
    stock_quantity: int = 0
    inventory_status: str = "available"
    market_availability: Dict[str, bool] = {}
    low_stock_warning: bool = False
    estimated_restock: Optional[str] = None
    inventory_last_updated: Optional[float] = None

class ProductListResponse(BaseModel):
    """Modelo de respuesta para lista de productos"""
    products: List[ProductResponse]
    total: int
    page: int
    limit: int
    has_next: bool
    market_id: str
    inventory_summary: Dict[str, Any] = {}

# Router
router = APIRouter(prefix="/v1", tags=["Products"])

# Variables globales para servicios
_inventory_service: Optional[InventoryService] = None
_availability_checker = None

def get_inventory_service() -> InventoryService:
    """Factory para obtener InventoryService singleton"""
    global _inventory_service
    if _inventory_service is None:
        try:
            # Intentar usar Redis si estÃ¡ disponible
            redis_client = RedisClient() if hasattr(RedisClient, '__call__') else None
            _inventory_service = create_inventory_service(redis_client)
        except Exception as e:
            logger.warning(f"Creating inventory service without Redis: {e}")
            _inventory_service = create_inventory_service(None)
    return _inventory_service

def get_availability_checker():
    """Factory para obtener AvailabilityChecker singleton"""
    global _availability_checker
    if _availability_checker is None:
        inventory_service = get_inventory_service()
        _availability_checker = create_availability_checker(inventory_service)
    return _availability_checker

@router.get(
    "/products/",
    response_model=ProductListResponse,
    summary="Obtener lista de productos",
    description="Obtiene lista paginada de productos con informaciÃ³n de inventario incluida"
)
async def get_products(
    limit: int = Query(default=10, ge=1, le=100, description="NÃºmero mÃ¡ximo de productos a retornar"),
    page: int = Query(default=1, ge=1, description="PÃ¡gina de resultados"),
    market_id: str = Query(default="US", description="ID del mercado para verificar disponibilidad"),
    include_inventory: bool = Query(default=True, description="Incluir informaciÃ³n de inventario"),
    category: Optional[str] = Query(default=None, description="Filtrar por categorÃ­a"),
    available_only: bool = Query(default=False, description="Solo productos disponibles"),
    api_key: str = Depends(get_api_key)
):
    """
    Obtener lista de productos con informaciÃ³n de inventario.
    
    Este endpoint:
    1. Obtiene productos desde Shopify
    2. Enriquece con informaciÃ³n de inventario
    3. Filtra por disponibilidad si se requiere
    4. Retorna resultados paginados
    """
    try:
        start_time = time.time()
        logger.info(f"Getting products: limit={limit}, page={page}, market={market_id}")
        
        # 1. Obtener productos desde Shopify
        shopify_client = get_shopify_client()
        if not shopify_client:
            # Fallback con productos simulados si no hay Shopify
            products = await _get_sample_products(limit, page)
        else:
            # Calcular offset para paginaciÃ³n
            offset = (page - 1) * limit
            products = await _get_shopify_products(shopify_client, limit, offset, category)
        
        if not products:
            return ProductListResponse(
                products=[],
                total=0,
                page=page,
                limit=limit,
                has_next=False,
                market_id=market_id,
                inventory_summary={}
            )
        
        # 2. Enriquecer con informaciÃ³n de inventario si se requiere
        if include_inventory:
            inventory_service = get_inventory_service()
            enriched_products = await inventory_service.enrich_products_with_inventory(
                products, market_id
            )
        else:
            enriched_products = products
        
        # 3. Filtrar por disponibilidad si se requiere
        if available_only:
            availability_checker = get_availability_checker()
            enriched_products = await availability_checker.filter_available_products(
                enriched_products, market_id
            )
        
        # 4. Convertir a modelos de respuesta
        product_responses = []
        for product in enriched_products[:limit]:  # Asegurar lÃ­mite
            try:
                product_response = ProductResponse(
                    id=str(product.get("id", "")),
                    title=product.get("title", ""),
                    description=product.get("description", ""),
                    price=float(product.get("price", 0)) if product.get("price") else None,
                    currency=product.get("currency", "USD"),
                    image_url=product.get("image_url") or product.get("featured_image"),
                    category=product.get("category") or product.get("product_type"),
                    
                    # Campos de inventario
                    availability=product.get("availability", "available"),
                    in_stock=product.get("in_stock", True),
                    stock_quantity=product.get("stock_quantity", 10),
                    inventory_status=product.get("inventory_status", "available"),
                    market_availability=product.get("market_availability", {market_id: True}),
                    low_stock_warning=product.get("low_stock_warning", False),
                    estimated_restock=product.get("estimated_restock"),
                    inventory_last_updated=product.get("inventory_last_updated")
                )
                product_responses.append(product_response)
            except Exception as e:
                logger.warning(f"Error processing product {product.get('id')}: {e}")
                continue
        
        # 5. Generar resumen de inventario
        inventory_summary = {}
        if include_inventory and product_responses:
            inventory_service = get_inventory_service()
            # Crear diccionario de inventario para el resumen
            inventory_dict = {
                p.id: type('InventoryInfo', (), {
                    'status': type('Status', (), {'value': p.inventory_status})(),
                    'available_quantity': p.stock_quantity
                })()
                for p in product_responses
            }
            inventory_summary = inventory_service.get_market_availability_summary(inventory_dict)
        
        # 6. Determinar si hay pÃ¡gina siguiente
        has_next = len(enriched_products) > limit
        
        # 7. Crear respuesta final
        response = ProductListResponse(
            products=product_responses,
            total=len(product_responses),
            page=page,
            limit=limit,
            has_next=has_next,
            market_id=market_id,
            inventory_summary=inventory_summary
        )
        
        execution_time = (time.time() - start_time) * 1000
        logger.info(f"âœ… Products endpoint: {len(product_responses)} products, {execution_time:.1f}ms")
        
        return response
        
    except Exception as e:
        logger.error(f"Error in get_products: {e}")
        raise HTTPException(
            status_code=500,
            detail=f"Error retrieving products: {str(e)}"
        )

@router.get(
    "/products/{product_id}",
    response_model=ProductResponse,
    summary="Obtener producto especÃ­fico",
    description="Obtiene informaciÃ³n detallada de un producto especÃ­fico con datos de inventario"
)
async def get_product(
    product_id: str,
    market_id: str = Query(default="US", description="ID del mercado"),
    include_inventory: bool = Query(default=True, description="Incluir informaciÃ³n de inventario"),
    api_key: str = Depends(get_api_key)
):
    """
    Obtener informaciÃ³n detallada de un producto especÃ­fico.
    """
    try:
        logger.info(f"Getting product {product_id} for market {market_id}")
        
        # 1. Obtener producto desde Shopify
        shopify_client = get_shopify_client()
        if not shopify_client:
            # Fallback con producto simulado
            product = await _get_sample_product(product_id)
        else:
            product = await _get_shopify_product(shopify_client, product_id)
        
        if not product:
            raise HTTPException(
                status_code=404,
                detail=f"Product {product_id} not found"
            )
        
        # 2. Enriquecer con informaciÃ³n de inventario
        if include_inventory:
            inventory_service = get_inventory_service()
            enriched_products = await inventory_service.enrich_products_with_inventory(
                [product], market_id
            )
            enriched_product = enriched_products[0] if enriched_products else product
        else:
            enriched_product = product
        
        # 3. Crear respuesta
        product_response = ProductResponse(
            id=str(enriched_product.get("id", product_id)),
            title=enriched_product.get("title", ""),
            description=enriched_product.get("description", ""),
            price=float(enriched_product.get("price", 0)) if enriched_product.get("price") else None,
            currency=enriched_product.get("currency", "USD"),
            image_url=enriched_product.get("image_url") or enriched_product.get("featured_image"),
            category=enriched_product.get("category") or enriched_product.get("product_type"),
            
            # Campos de inventario
            availability=enriched_product.get("availability", "available"),
            in_stock=enriched_product.get("in_stock", True),
            stock_quantity=enriched_product.get("stock_quantity", 10),
            inventory_status=enriched_product.get("inventory_status", "available"),
            market_availability=enriched_product.get("market_availability", {market_id: True}),
            low_stock_warning=enriched_product.get("low_stock_warning", False),
            estimated_restock=enriched_product.get("estimated_restock"),
            inventory_last_updated=enriched_product.get("inventory_last_updated")
        )
        
        logger.info(f"âœ… Product {product_id}: {product_response.availability}")
        return product_response
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error getting product {product_id}: {e}")
        raise HTTPException(
            status_code=500,
            detail=f"Error retrieving product: {str(e)}"
        )

# Funciones helper para obtener productos

async def _get_shopify_products(
    shopify_client, 
    limit: int, 
    offset: int = 0, 
    category: Optional[str] = None
) -> List[Dict]:
    """Obtener productos desde Shopify"""
    try:
        # Esta implementaciÃ³n depende de la implementaciÃ³n especÃ­fica del cliente Shopify
        # Por ahora, retornamos productos simulados
        logger.info(f"Hola, shopify client {shopify_client.access_token}")
        return await _get_sample_products(limit, offset // limit + 1, category)
    except Exception as e:
        logger.warning(f"Error getting Shopify products: {e}")
        return await _get_sample_products(limit, offset // limit + 1, category)

async def _get_shopify_product(shopify_client, product_id: str) -> Optional[Dict]:
    """Obtener producto especÃ­fico desde Shopify"""
    try:
        # ImplementaciÃ³n especÃ­fica del cliente Shopify
        return await _get_sample_product(product_id)
    except Exception as e:
        logger.warning(f"Error getting Shopify product {product_id}: {e}")
        return await _get_sample_product(product_id)

async def _get_sample_products(limit: int, page: int = 1, category: Optional[str] = None) -> List[Dict]:
    """Generar productos de ejemplo para testing"""
    products = [
        {
            "id": f"prod_{i:03d}",
            "title": f"Producto Ejemplo {i}",
            "description": f"DescripciÃ³n del producto ejemplo nÃºmero {i}",
            "price": 25.99 + (i * 5.0),
            "currency": "USD",
            "featured_image": f"https://example.com/image_{i}.jpg",
            "product_type": "clothing" if i % 2 == 0 else "accessories",
            "category": "clothing" if i % 2 == 0 else "accessories"
        }
        for i in range(1, 51)  # 50 productos de ejemplo
    ]
    
    # Filtrar por categorÃ­a si se especifica
    if category:
        products = [p for p in products if p.get("category") == category]
    
    # PaginaciÃ³n
    start_idx = (page - 1) * limit
    end_idx = start_idx + limit
    
    return products[start_idx:end_idx]

async def _get_sample_product(product_id: str) -> Optional[Dict]:
    """Obtener producto de ejemplo especÃ­fico"""
    try:
        # Extraer nÃºmero del ID
        if product_id.startswith("prod_"):
            num = int(product_id.split("_")[1])
        else:
            num = 1
        
        return {
            "id": product_id,
            "title": f"Producto Ejemplo {num}",
            "description": f"DescripciÃ³n detallada del producto ejemplo nÃºmero {num}",
            "price": 25.99 + (num * 5.0),
            "currency": "USD",
            "featured_image": f"https://example.com/image_{num}.jpg",
            "product_type": "clothing" if num % 2 == 0 else "accessories",
            "category": "clothing" if num % 2 == 0 else "accessories"
        }
    except:
        return {
            "id": product_id,
            "title": "Producto Ejemplo",
            "description": "DescripciÃ³n de ejemplo",
            "price": 29.99,
            "currency": "USD",
            "featured_image": "https://example.com/image.jpg",
            "product_type": "clothing",
            "category": "clothing"
        }

# ========================================================================
# ğŸ” DEBUG ENDPOINTS - TEMPORALES PARA DEBUGGING
# ========================================================================

@router.get(
    "/debug/headers",
    summary="ğŸ” Debug Headers",
    description="Endpoint temporal para debugging de headers de autenticaciÃ³n",
    tags=["Debug"]
)
async def debug_headers(request: Request):
    """
    ğŸ” Endpoint debug para investigar problemas de autenticaciÃ³n.
    
    Este endpoint NO requiere autenticaciÃ³n y muestra todos los headers
    recibidos para diagnosticar problemas con X-API-Key.
    """
    import time
    
    return {
        "timestamp": time.time(),
        "method": request.method,
        "url": str(request.url),
        "client_host": request.client.host if request.client else "unknown",
        "headers": {
            # Convertir headers a dict para JSON serialization
            key: value for key, value in request.headers.items()
        },
        "specific_headers": {
            "x_api_key": request.headers.get("X-API-Key"),
            "x_api_key_present": "X-API-Key" in request.headers,
            "authorization": request.headers.get("Authorization"),
            "content_type": request.headers.get("Content-Type"),
            "user_agent": request.headers.get("User-Agent"),
            "origin": request.headers.get("Origin"),
            "referer": request.headers.get("Referer")
        },
        "header_analysis": {
            "total_headers_count": len(request.headers),
            "x_api_key_length": len(request.headers.get("X-API-Key", "")),
            "expected_api_key": "2fed9999056fab6dac5654238f0cae1c",
            "api_key_matches": request.headers.get("X-API-Key") == "2fed9999056fab6dac5654238f0cae1c"
        }
    }

@router.get(
    "/debug/auth-test",
    summary="ğŸ” Debug Auth Test",
    description="Endpoint que requiere autenticaciÃ³n para testing",
    tags=["Debug"]
)
async def debug_auth_test(
    request: Request,
    api_key: str = Depends(get_api_key)
):
    """
    ğŸ” Endpoint debug que SÃ requiere autenticaciÃ³n.
    
    Si este endpoint funciona, significa que la autenticaciÃ³n estÃ¡ OK.
    Si falla, podemos comparar con /debug/headers para ver quÃ© cambiÃ³.
    """
    import time
    
    return {
        "timestamp": time.time(),
        "status": "authenticated_successfully",
        "message": "âœ… Authentication working correctly!",
        "api_key_validated": api_key[:10] + "...",  # Solo primeros 10 chars por seguridad
        "headers_received": {
            key: value for key, value in request.headers.items()
        },
        "auth_flow": "Headers â†’ FastAPI â†’ APIKeyHeader â†’ get_api_key() â†’ SUCCESS"
    }

@router.get(
    "/debug/load-test",
    summary="ğŸš€ Debug Load Test",
    description="Endpoint optimizado para load testing debugging",
    tags=["Debug"]
)
async def debug_load_test(
    request: Request,
    api_key: str = Depends(get_api_key),
    test_id: Optional[str] = Query(None, description="ID del test para tracking")
):
    """
    ğŸš€ Endpoint especÃ­fico para debugging de load testing.
    
    Retorna informaciÃ³n mÃ­nima para reducir overhead durante tests de carga.
    """
    import time
    
    return {
        "test_id": test_id or "no_id",
        "timestamp": time.time(),
        "status": "ok",
        "auth": "valid",
        "api_key_prefix": api_key[:8],
        "response_time_start": time.time()
    }
