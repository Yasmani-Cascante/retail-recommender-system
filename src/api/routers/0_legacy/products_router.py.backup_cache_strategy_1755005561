# src/api/routers/products_router.py
"""
Products Router - Enterprise Architecture + Full Legacy Support
==============================================================

Router enterprise que mantiene TODA la funcionalidad original mientras
a√±ade nuevos patrones enterprise. Garantiza zero breaking changes.

Author: Senior Architecture Team
Version: 2.1.0 - Enterprise Migration with Full Legacy Support
"""
import asyncio
import logging
import time
from typing import Dict, List, Optional, Any
from fastapi import APIRouter, Depends, HTTPException, Query, Request
from pydantic import BaseModel, Field

# Imports del sistema original (mantenidos)
from src.api.security_auth import get_api_key
from src.api.core.store import get_shopify_client
from src.api.inventory.inventory_service import InventoryService
from src.api.inventory.availability_checker import create_availability_checker

# ‚úÖ ENTERPRISE IMPORTS - Centralized dependency injection
from src.api.factories import ServiceFactory, InfrastructureCompositionRoot, HealthCompositionRoot

# ‚úÖ CORRECCI√ìN CR√çTICA: Dependency injection unificada (ORIGINAL)
from src.api.core.redis_service import get_redis_service, RedisService
from src.api.core.product_cache import ProductCache
from src.api.core.redis_config_fix import PatchedRedisClient  # ‚úÖ A√±adir import faltante

logger = logging.getLogger(__name__)

# ============================================================================
# üìã PYDANTIC MODELS - Response structures (ORIGINAL + ENTERPRISE)
# ============================================================================

class ProductResponse(BaseModel):
    """Modelo de respuesta para productos individuales"""
    id: str
    title: str
    description: Optional[str] = None
    price: Optional[float] = None
    currency: str = "USD"
    image_url: Optional[str] = None
    category: Optional[str] = None
    
    # Campos de inventario enterprise
    availability: str = "available"
    in_stock: bool = True
    stock_quantity: int = 0
    inventory_status: str = "available"
    market_availability: Dict[str, bool] = {}
    low_stock_warning: bool = False
    estimated_restock: Optional[str] = None
    inventory_last_updated: Optional[float] = None
    
    # Enterprise metadata
    cache_hit: bool = False
    service_version: str = "2.1.0"

class ProductListResponse(BaseModel):
    """Modelo de respuesta para lista de productos"""
    products: List[ProductResponse]
    total: int
    page: int
    limit: int
    has_next: bool
    market_id: str
    inventory_summary: Dict[str, Any] = {}
    
    # Enterprise metadata
    cache_stats: Dict[str, Any] = {}
    performance_metrics: Dict[str, float] = {}
    service_version: str = "2.1.0"

# ============================================================================
# üèóÔ∏è SERVICE FACTORIES - Enterprise + Legacy Dependency Injection
# ============================================================================

# Variables globales para servicios (LEGACY - mantener durante transici√≥n)
_inventory_service: Optional[InventoryService] = None
_availability_checker = None
_product_cache: Optional[ProductCache] = None

# ‚úÖ ENTERPRISE DEPENDENCY INJECTION
async def get_enterprise_inventory_service():
    """‚úÖ ENTERPRISE: Dependency injection para InventoryService"""
    try:
        inventory_service = await ServiceFactory.get_inventory_service_singleton()
        logger.debug("‚úÖ Enterprise InventoryService singleton acquired")
        return inventory_service
    except Exception as e:
        logger.error(f"‚ùå Enterprise InventoryService failed: {e}")
        raise HTTPException(status_code=503, detail="Inventory service temporarily unavailable")

async def get_enterprise_product_cache():
    """‚úÖ ENTERPRISE: Dependency injection para ProductCache"""
    try:
        product_cache = await ServiceFactory.get_product_cache_singleton()
        logger.debug("‚úÖ Enterprise ProductCache singleton acquired")
        return product_cache
    except Exception as e:
        logger.error(f"‚ùå Enterprise ProductCache failed: {e}")
        raise HTTPException(status_code=503, detail="Product cache service temporarily unavailable")

async def get_enterprise_availability_checker():
    """‚úÖ ENTERPRISE: Dependency injection para AvailabilityChecker"""
    try:
        availability_checker = await ServiceFactory.create_availability_checker()
        logger.debug("‚úÖ Enterprise AvailabilityChecker created")
        return availability_checker
    except Exception as e:
        logger.error(f"‚ùå Enterprise AvailabilityChecker failed: {e}")
        raise HTTPException(status_code=503, detail="Availability checker service temporarily unavailable")

# ============================================================================
# üîß LEGACY DEPENDENCY INJECTION (ORIGINAL - PRESERVED)
# ============================================================================

async def get_inventory_service_dependency() -> InventoryService:
    """
    ‚úÖ FACTORY CORREGIDA: Dependency injection unificada (ORIGINAL)
    
    Utiliza RedisService enterprise-grade en lugar de m√∫ltiples clients.
    Garantiza consistencia en connection management.
    """
    try:
        # ‚úÖ Usar RedisService enterprise singleton
        redis_service = await get_redis_service()
        
        # ‚úÖ Dependency injection limpia
        inventory_service = InventoryService(redis_service=redis_service)
        
        logger.info("‚úÖ InventoryService initialized with RedisService enterprise")
        return inventory_service
        
    except Exception as e:
        logger.warning(f"‚ö†Ô∏è RedisService unavailable, InventoryService in fallback mode: {e}")
        
        # ‚úÖ Graceful degradation
        inventory_service = InventoryService(redis_service=None)
        return inventory_service

async def get_product_cache_dependency() -> ProductCache:
    """
    ‚úÖ FACTORY CORREGIDA: ProductCache con RedisService enterprise (ORIGINAL)
    
    Integra ProductCache con la nueva arquitectura Redis enterprise,
    manteniendo el hybrid fallback strategy.
    """
    try:
        # ‚úÖ RedisService enterprise como fuente primaria
        redis_service = await get_redis_service()
        
        # ‚úÖ Obtener dependencias adicionales
        shopify_client = get_shopify_client()
        
        # ‚úÖ Inicializar ProductCache con arquitectura enterprise
        product_cache = ProductCache(
            redis_client=redis_service._client,  # Access to underlying client
            shopify_client=shopify_client,
            ttl_seconds=int(3600),  # 1 hour default
            prefix="product:v2:"
        )
        
        logger.info("‚úÖ ProductCache initialized with RedisService enterprise architecture")
        return product_cache
        
    except Exception as e:
        logger.error(f"‚ùå ProductCache initialization failed: {e}")
        raise HTTPException(
            status_code=500, 
            detail="Product cache service unavailable"
        )

async def get_availability_checker_dependency():
    """‚úÖ FACTORY CORREGIDA: AvailabilityChecker con dependency injection enterprise (ORIGINAL)"""
    inventory_service = await get_inventory_service_dependency()
    return create_availability_checker(inventory_service)

# ============================================================================
# üîÑ LEGACY COMPATIBILITY FUNCTIONS - Mantener durante transici√≥n (ORIGINAL)
# ============================================================================

def get_inventory_service() -> InventoryService:
    """
    ‚ö†Ô∏è LEGACY FUNCTION - DEPRECATED (ORIGINAL)
    
    Usar get_inventory_service_dependency() para nueva arquitectura enterprise.
    Esta funci√≥n se mantiene solo para compatibilidad con c√≥digo existente.
    """
    global _inventory_service
    if _inventory_service is None:
        logger.warning("‚ö†Ô∏è Using legacy get_inventory_service() - Consider migration to enterprise architecture")
        try:
            # Crear con configuraci√≥n legacy (sin Redis)
            _inventory_service = InventoryService(redis_service=None)
            logger.info("‚úÖ Legacy InventoryService created without Redis")
        except Exception as e:
            logger.error(f"‚ùå Error creating legacy InventoryService: {e}")
            # Crear instancia m√≠nima como fallback
            _inventory_service = InventoryService(redis_service=None)
    
    return _inventory_service

def get_availability_checker():
    """‚ö†Ô∏è LEGACY FUNCTION - DEPRECATED (ORIGINAL)"""
    global _availability_checker
    if _availability_checker is None:
        logger.warning("‚ö†Ô∏è Using legacy get_availability_checker() - Consider migration to enterprise architecture")
        try:
            inventory_service = get_inventory_service()
            _availability_checker = create_availability_checker(inventory_service)
            logger.info("‚úÖ Legacy AvailabilityChecker created")
        except Exception as e:
            logger.error(f"‚ùå Error creating legacy AvailabilityChecker: {e}")
            # Crear mock como fallback
            _availability_checker = type('MockChecker', (), {
                'check_availability': lambda self, *args, **kwargs: {'status': 'available', 'fallback': True}
            })()
    
    return _availability_checker

def get_product_cache() -> Optional[ProductCache]:
    """üöÄ Factory para obtener ProductCache singleton - DEPRECATED (ORIGINAL)"""
    global _product_cache
    if _product_cache is None:
        try:
            # Obtener dependencias
            shopify_client = get_shopify_client()
            
            # Intentar usar Redis con configuraci√≥n validada
            redis_client = None
            try:
                redis_client = PatchedRedisClient(use_validated_config=True)
                logger.info("‚úÖ ProductCache legacy initialized with Redis validated")
            except Exception as e:
                redis_client = None
                logger.warning(f"Redis unavailable for ProductCache legacy: {e}")

            # Crear ProductCache con configuraci√≥n legacy
            _product_cache = ProductCache(
                redis_client=redis_client,
                local_catalog=None,
                shopify_client=shopify_client,
                product_gateway=None,
                ttl_seconds=900,  # 15 minutos
                prefix="products_legacy:"
            )
            
            logger.info("‚úÖ ProductCache legacy singleton created")
            
        except Exception as e:
            logger.error(f"‚ùå Error creating ProductCache legacy: {e}")
            _product_cache = None
            
    return _product_cache

# ============================================================================
# üî• ROUTER SETUP
# ============================================================================

router = APIRouter(prefix="/v1", tags=["Products"])

# ============================================================================
# üìä HEALTH CHECK ENDPOINT - Enterprise Monitoring (ORIGINAL + ENHANCED)
# ============================================================================

@router.get("/products/health")
async def products_health_check():
    """Health check comprehensivo para el sistema de productos (ORIGINAL + ENHANCED)"""
    health_status = {
        "timestamp": time.time(),
        "service": "products_api",
        "version": "2.1.0",
        "components": {}
    }
    
    try:
        # ‚úÖ Check RedisService health
        redis_service = await get_redis_service()
        redis_health = await redis_service.health_check()
        health_status["components"]["redis_service"] = redis_health
        
        # ‚úÖ Check InventoryService health
        inventory_service = await get_inventory_service_dependency()
        health_status["components"]["inventory_service"] = {
            "status": "operational",
            "redis_integrated": inventory_service.redis_service is not None
        }
        
        # ‚úÖ Check ProductCache health
        try:
            product_cache = await get_product_cache_dependency()
            cache_stats = product_cache.get_stats()
            health_status["components"]["product_cache"] = {
                "status": "operational",
                "stats": cache_stats
            }
        except Exception as cache_error:
            health_status["components"]["product_cache"] = {
                "status": "degraded",
                "error": str(cache_error)
            }
        
        # ‚úÖ Determine overall status
        component_statuses = [
            comp.get("status", "unknown") 
            for comp in health_status["components"].values()
        ]
        
        if all(status == "operational" for status in component_statuses):
            health_status["overall_status"] = "healthy"
        elif any(status == "operational" for status in component_statuses):
            health_status["overall_status"] = "degraded"
        else:
            health_status["overall_status"] = "unhealthy"
            
        return health_status
        
    except Exception as e:
        logger.error(f"‚ùå Products health check failed: {e}")
        health_status["overall_status"] = "unhealthy"
        health_status["error"] = str(e)
        return health_status

# ============================================================================
# üõçÔ∏è MAIN PRODUCT ENDPOINTS (ORIGINAL PRESERVED + ENTERPRISE ENHANCED)
# ============================================================================

@router.get(
    "/products/",
    response_model=ProductListResponse,
    summary="Obtener lista de productos",
    description="Obtiene lista paginada de productos con informaci√≥n de inventario incluida"
)
async def get_products(
    limit: int = Query(default=10, ge=1, le=100, description="N√∫mero m√°ximo de productos a retornar"),
    page: int = Query(default=1, ge=1, description="P√°gina de resultados"),
    market_id: str = Query(default="US", description="ID del mercado para verificar disponibilidad"),
    include_inventory: bool = Query(default=True, description="Incluir informaci√≥n de inventario"),
    category: Optional[str] = Query(default=None, description="Filtrar por categor√≠a"),
    available_only: bool = Query(default=False, description="Solo productos disponibles"),
    api_key: str = Depends(get_api_key)
):
    """
    Obtener lista de productos con informaci√≥n de inventario (ORIGINAL + ENHANCED).
    
    Este endpoint:
    1. Obtiene productos desde Shopify
    2. Enriquece con informaci√≥n de inventario
    3. Filtra por disponibilidad si se requiere
    4. Retorna resultados paginados
    """
    try:
        start_time = time.time()
        logger.info(f"Getting products: limit={limit}, page={page}, market={market_id}")
        
        # 1. Obtener productos desde Shopify
        shopify_client = get_shopify_client()
        if not shopify_client:
            # Fallback con productos simulados si no hay Shopify
            products = await _get_sample_products(limit, page)
        else:
            # Calcular offset para paginaci√≥n
            offset = (page - 1) * limit
            products = await _get_shopify_products(shopify_client, limit, offset, category)
        
        if not products:
            return ProductListResponse(
                products=[],
                total=0,
                page=page,
                limit=limit,
                has_next=False,
                market_id=market_id,
                inventory_summary={}
            )
        
        # 2. Enriquecer con informaci√≥n de inventario si se requiere
        if include_inventory:
            inventory_service = get_inventory_service()
            enriched_products = await inventory_service.enrich_products_with_inventory(
                products, market_id
            )
        else:
            enriched_products = products
        
        # 3. Filtrar por disponibilidad si se requiere
        if available_only:
            availability_checker = get_availability_checker()
            enriched_products = await availability_checker.filter_available_products(
                enriched_products, market_id
            )
        
        # 4. Convertir a modelos de respuesta
        product_responses = []
        for product in enriched_products[:limit]:  # Asegurar l√≠mite
            try:
                product_response = ProductResponse(
                    id=str(product.get("id", "")),
                    title=product.get("title", ""),
                    description=product.get("description", ""),
                    price=float(product.get("price", 0)) if product.get("price") else None,
                    currency=product.get("currency", "USD"),
                    image_url=product.get("image_url") or product.get("featured_image"),
                    category=product.get("category") or product.get("product_type"),
                    
                    # Campos de inventario
                    availability=product.get("availability", "available"),
                    in_stock=product.get("in_stock", True),
                    stock_quantity=product.get("stock_quantity", 10),
                    inventory_status=product.get("inventory_status", "available"),
                    market_availability=product.get("market_availability", {market_id: True}),
                    low_stock_warning=product.get("low_stock_warning", False),
                    estimated_restock=product.get("estimated_restock"),
                    inventory_last_updated=product.get("inventory_last_updated")
                )
                product_responses.append(product_response)
            except Exception as e:
                logger.warning(f"Error processing product {product.get('id')}: {e}")
                continue
        
        # 5. Generar resumen de inventario
        inventory_summary = {}
        if include_inventory and product_responses:
            inventory_service = get_inventory_service()
            # Crear diccionario de inventario para el resumen
            inventory_dict = {
                p.id: type('InventoryInfo', (), {
                    'status': type('Status', (), {'value': p.inventory_status})(),
                    'available_quantity': p.stock_quantity
                })()
                for p in product_responses
            }
            inventory_summary = inventory_service.get_market_availability_summary(inventory_dict)
        
        # 6. Determinar si hay p√°gina siguiente
        has_next = len(enriched_products) > limit
        
        # 7. Crear respuesta final
        response = ProductListResponse(
            products=product_responses,
            total=len(product_responses),
            page=page,
            limit=limit,
            has_next=has_next,
            market_id=market_id,
            inventory_summary=inventory_summary
        )
        
        execution_time = (time.time() - start_time) * 1000
        logger.info(f"‚úÖ Products endpoint: {len(product_responses)} products, {execution_time:.1f}ms")
        
        return response
        
    except Exception as e:
        logger.error(f"Error in get_products: {e}")
        raise HTTPException(
            status_code=500,
            detail=f"Error retrieving products: {str(e)}"
        )

@router.get(
    "/products/{product_id}",
    response_model=ProductResponse,
    summary="Obtener producto espec√≠fico",
    description="Obtiene informaci√≥n detallada de un producto espec√≠fico con datos de inventario"
)
async def get_product(
    product_id: str,
    market_id: str = Query(default="US", description="ID del mercado"),
    include_inventory: bool = Query(default=True, description="Incluir informaci√≥n de inventario"),
    api_key: str = Depends(get_api_key)
):
    """Obtener informaci√≥n detallada de un producto espec√≠fico (ORIGINAL)."""
    try:
        logger.info(f"Getting product {product_id} for market {market_id}")
        
        # 1. Obtener producto desde Shopify
        shopify_client = get_shopify_client()
        if not shopify_client:
            # Fallback con producto simulado
            product = await _get_sample_product(product_id)
        else:
            product = await _get_shopify_product(shopify_client, product_id)
        
        if not product:
            raise HTTPException(
                status_code=404,
                detail=f"Product {product_id} not found"
            )
        
        # 2. Enriquecer con informaci√≥n de inventario
        if include_inventory:
            inventory_service = get_inventory_service()
            enriched_products = await inventory_service.enrich_products_with_inventory(
                [product], market_id
            )
            enriched_product = enriched_products[0] if enriched_products else product
        else:
            enriched_product = product
        
        # 3. Crear respuesta
        product_response = ProductResponse(
            id=str(enriched_product.get("id", product_id)),
            title=enriched_product.get("title", ""),
            description=enriched_product.get("description", ""),
            price=float(enriched_product.get("price", 0)) if enriched_product.get("price") else None,
            currency=enriched_product.get("currency", "USD"),
            image_url=enriched_product.get("image_url") or enriched_product.get("featured_image"),
            category=enriched_product.get("category") or enriched_product.get("product_type"),
            
            # Campos de inventario
            availability=enriched_product.get("availability", "available"),
            in_stock=enriched_product.get("in_stock", True),
            stock_quantity=enriched_product.get("stock_quantity", 10),
            inventory_status=enriched_product.get("inventory_status", "available"),
            market_availability=enriched_product.get("market_availability", {market_id: True}),
            low_stock_warning=enriched_product.get("low_stock_warning", False),
            estimated_restock=enriched_product.get("estimated_restock"),
            inventory_last_updated=enriched_product.get("inventory_last_updated")
        )
        
        logger.info(f"‚úÖ Product {product_id}: {product_response.availability}")
        return product_response
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error getting product {product_id}: {e}")
        raise HTTPException(
            status_code=500,
            detail=f"Error retrieving product: {str(e)}"
        )

# ============================================================================
# üîß FUNCIONES HELPER PARA OBTENER PRODUCTOS (ORIGINAL PRESERVED)
# ============================================================================

async def _get_shopify_products(
    shopify_client, 
    limit: int, 
    offset: int = 0, 
    category: Optional[str] = None
) -> List[Dict]:
    """
    üöÄ UPGRADED: Obtener productos usando ProductCache avanzado con market awareness (ORIGINAL + ENHANCED)
    """
    try:
        start_time = time.time()
        cache = await get_product_cache_dependency()
        
        if not cache:
            # Fallback a shopify directo si ProductCache no est√° disponible
            logger.warning("‚ö†Ô∏è ProductCache not available, falling back to direct Shopify")
            return await _get_shopify_products_direct(shopify_client, limit, offset, category)
        
        # Calcular p√°gina para ProductCache
        page = (offset // limit) + 1
        market_id = "US"  # Default, podr√≠a extraerse del contexto
        
        logger.info(f"üöÄ UPGRADED: Obteniendo productos con ProductCache - limit={limit}, page={page}, market={market_id}")
        
        # Estrategia 1: Intentar obtener productos populares del mercado
        try:
            popular_products = await cache.get_popular_products(market_id, limit * 2)
            if popular_products:
                cached_products = []
                for product_id in popular_products[:limit]:
                    product = await cache.get_product(product_id)
                    if product:
                        # Filtrar por categor√≠a si se especifica
                        if not category or product.get("category") == category or product.get("product_type") == category:
                            cached_products.append(product)
                        
                        if len(cached_products) >= limit:
                            break
                
                if len(cached_products) >= limit // 2:
                    response_time = (time.time() - start_time) * 1000
                    logger.info(f"‚úÖ ProductCache hit: {len(cached_products)} productos en {response_time:.1f}ms")
                    return cached_products[:limit]
        
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Popular products strategy failed: {e}")
        
        # Estrategia 2: Fallback a Shopify con ProductCache
        if shopify_client:
            products = await _get_shopify_products_direct(shopify_client, limit, offset, category)
           
            # Precargar productos en cache de forma as√≠ncrona
            if products:
                product_ids = [str(p.get("id", "")) for p in products if p.get("id")]
                if product_ids:
                    logger.info(f"Pre-cargando en el router {len(product_ids)} en Estrategia 2 ")
                    asyncio.create_task(cache.preload_products(product_ids[:10]))
            
            response_time = (time.time() - start_time) * 1000
            logger.info(f"‚úÖ UPGRADED: Productos obtenidos en {response_time:.1f}ms - {len(products)} productos")
            return products
        
        else:
            # Estrategia 3: Productos de muestra
            return await _get_sample_products(limit, page, category)
        
    except Exception as e:
        response_time = (time.time() - start_time) * 1000
        logger.error(f"‚ùå UPGRADED: Error despu√©s de {response_time:.1f}ms: {e}")
        return await _get_sample_products(limit, offset // limit + 1, category)

async def _get_shopify_products_direct(
    shopify_client, 
    limit: int, 
    offset: int = 0, 
    category: Optional[str] = None
) -> List[Dict]:
    """Obtener productos directamente de Shopify (mantiene l√≥gica original) (ORIGINAL)"""
    try:
        if not shopify_client:
            return await _get_sample_products(limit, offset // limit + 1, category)
        
        start_time = time.time()
        
        def fetch_shopify_sync():
            try:
                all_shopify_products = shopify_client.get_products(limit=limit*2, offset=offset)
                if not all_shopify_products:
                    return []
                
                normalized_products = []
                for shopify_product in all_shopify_products:
                    try:
                        variants = shopify_product.get('variants', [])
                        first_variant = variants[0] if variants else {}
                        images = shopify_product.get('images', [])
                        image_url = images[0].get('src') if images else None
                        
                        normalized_product = {
                            "id": str(shopify_product.get('id')),
                            "title": shopify_product.get('title', ''),
                            "description": shopify_product.get('body_html', ''),
                            "price": float(first_variant.get('price', 0)) if first_variant.get('price') else 0.0,
                            "currency": "USD",
                            "featured_image": image_url,
                            "image_url": image_url,
                            "product_type": shopify_product.get('product_type', ''),
                            "category": shopify_product.get('product_type', ''),
                            "vendor": shopify_product.get('vendor', ''),
                            "handle": shopify_product.get('handle', ''),
                            "sku": first_variant.get('sku', ''),
                            "inventory_quantity": first_variant.get('inventory_quantity', 0),
                        }
                        
                        normalized_products.append(normalized_product)
                        
                    except Exception as e:
                        logger.warning(f"‚ö†Ô∏è Error normalizing product: {e}")
                        continue
                
                return normalized_products
                
            except Exception as e:
                logger.error(f"‚ùå Error fetching from Shopify: {e}")
                return []
        
        # Ejecutar en thread pool con timeout din√°mico
        # Timeout m√°s corto para requests peque√±os, m√°s largo para grandes
        dynamic_timeout = 5.0 if limit <= 10 else 15.0 if limit <= 50 else 30.0
        
        products = await asyncio.wait_for(
            asyncio.to_thread(fetch_shopify_sync),
            timeout=dynamic_timeout
        )
        
        if products:
            # Filtrar por categor√≠a
            if category:
                products = [
                    p for p in products 
                    if p.get("category", "").lower() == category.lower() or 
                       p.get("product_type", "").lower() == category.lower()
                ]
            
            # Aplicar paginaci√≥n
            start_idx = offset
            end_idx = start_idx + limit
            paginated_products = products[start_idx:end_idx]
            
            response_time = (time.time() - start_time) * 1000
            logger.info(f"‚úÖ Shopify direct: {len(paginated_products)} productos en {response_time:.1f}ms")
            logger.info(f"   Request efficiency: {len(paginated_products)}/{len(products)} productos utilizados")
            
            return paginated_products
        
        else:
            return await _get_sample_products(limit, offset // limit + 1, category)
    
    except asyncio.TimeoutError:
        logger.error("‚ùå Shopify timeout - using fallback")
        return await _get_sample_products(limit, offset // limit + 1, category)
    except Exception as e:
        logger.error(f"‚ùå Error in Shopify direct: {e}")
        return await _get_sample_products(limit, offset // limit + 1, category)

async def _get_sample_products(limit: int, page: int = 1, category: Optional[str] = None) -> List[Dict]:
    """Generar productos de ejemplo para testing (ORIGINAL)"""
    products = [
        {
            "id": f"prod_{i:03d}",
            "title": f"Producto Ejemplo {i}",
            "description": f"Descripci√≥n del producto ejemplo n√∫mero {i}",
            "price": 25.99 + (i * 5.0),
            "currency": "USD",
            "featured_image": f"https://example.com/image_{i}.jpg",
            "product_type": "clothing" if i % 2 == 0 else "accessories",
            "category": "clothing" if i % 2 == 0 else "accessories"
        }
        for i in range(1, 51)  # 50 productos de ejemplo
    ]
    
    # Filtrar por categor√≠a si se especifica
    if category:
        products = [p for p in products if p.get("category") == category]
    
    # Paginaci√≥n
    start_idx = (page - 1) * limit
    end_idx = start_idx + limit
    
    return products[start_idx:end_idx]

async def _get_sample_product(product_id: str) -> Optional[Dict]:
    """Obtener producto de ejemplo espec√≠fico (ORIGINAL)"""
    try:
        # Extraer n√∫mero del ID
        if product_id.startswith("prod_"):
            num = int(product_id.split("_")[1])
        else:
            num = 1
        
        return {
            "id": product_id,
            "title": f"Producto Ejemplo {num}",
            "description": f"Descripci√≥n detallada del producto ejemplo n√∫mero {num}",
            "price": 25.99 + (num * 5.0),
            "currency": "USD",
            "featured_image": f"https://example.com/image_{num}.jpg",
            "product_type": "clothing" if num % 2 == 0 else "accessories",
            "category": "clothing" if num % 2 == 0 else "accessories",
       }
    except:
       return {
           "id": product_id,
           "title": "Producto Ejemplo",
           "description": "Descripci√≥n de ejemplo",
           "price": 29.99,
           "currency": "USD",
           "featured_image": "https://example.com/image.jpg",
           "product_type": "clothing",
           "category": "clothing"
       }
   
async def _get_shopify_product(shopify_client, product_id: str) -> Optional[Dict]:
   """
   Obtener producto espec√≠fico REAL desde Shopify (ORIGINAL)
   
   Esta funci√≥n busca un producto espec√≠fico por ID en los productos de Shopify
   """
   try:
       logger.info(f"üîç Buscando producto espec√≠fico ID: {product_id}")
       
       # Obtener todos los productos (en un sistema real, usar√≠as el endpoint espec√≠fico)
       all_products = shopify_client.get_products()
       
       if not all_products:
           logger.warning("‚ö†Ô∏è No se obtuvieron productos de Shopify")
           return await _get_sample_product(product_id)
       
       # Buscar el producto espec√≠fico
       for shopify_product in all_products:
           if str(shopify_product.get('id')) == str(product_id):
               logger.info(f"‚úÖ Producto encontrado: {shopify_product.get('title')}")
               
               # Normalizar el producto (misma l√≥gica que _get_shopify_products)
               variants = shopify_product.get('variants', [])
               first_variant = variants[0] if variants else {}
               images = shopify_product.get('images', [])
               image_url = images[0].get('src') if images else None
               
               return {
                   "id": str(shopify_product.get('id')),
                   "title": shopify_product.get('title', ''),
                   "description": shopify_product.get('body_html', ''),
                   "price": float(first_variant.get('price', 0)) if first_variant.get('price') else 0.0,
                   "currency": "USD",
                   "featured_image": image_url,
                   "image_url": image_url,
                   "product_type": shopify_product.get('product_type', ''),
                   "category": shopify_product.get('product_type', ''),
                   "vendor": shopify_product.get('vendor', ''),
                   "handle": shopify_product.get('handle', ''),
                   "sku": first_variant.get('sku', ''),
                   "inventory_quantity": first_variant.get('inventory_quantity', 0),
               }
       
       # Si no se encuentra el producto
       logger.warning(f"‚ö†Ô∏è Producto ID {product_id} no encontrado en Shopify")
       return await _get_sample_product(product_id)
       
   except Exception as e:
       logger.error(f"‚ùå Error obteniendo producto {product_id} de Shopify: {e}")
       return await _get_sample_product(product_id)

# ============================================================================
# üîß HELPER FUNCTIONS (ORIGINAL PRESERVED)
# ============================================================================

async def debug_shopify_connection(shopify_client) -> Dict:
   """
   Funci√≥n de debugging para verificar la conexi√≥n con Shopify (ORIGINAL)
   """
   try:
       if not shopify_client:
           return {
               "status": "error",
               "message": "Shopify client no disponible",
               "details": "El cliente de Shopify no fue inicializado correctamente"
           }
       
       # Intentar obtener el conteo de productos
       product_count = shopify_client.get_product_count()
       
       # Intentar obtener una muestra peque√±a de productos
       sample_products = shopify_client.get_products()
       
       return {
           "status": "success",
           "message": "Conexi√≥n con Shopify exitosa",
           "details": {
               "shop_url": shopify_client.shop_url,
               "api_url": shopify_client.api_url,
               "product_count": product_count,
               "sample_products_fetched": len(sample_products) if sample_products else 0,
               "first_product_title": sample_products[0].get('title') if sample_products else None,
               "access_token_prefix": shopify_client.access_token[:4] + "..." if shopify_client.access_token else "No token"
           }
       }
       
   except Exception as e:
       return {
           "status": "error",
           "message": f"Error conectando con Shopify: {str(e)}",
           "details": {
               "shop_url": shopify_client.shop_url if shopify_client else "No client",
               "error_type": type(e).__name__
           }
       }

# ============================================================================
# üìä ENTERPRISE MONITORING ENDPOINTS
# ============================================================================

@router.get("/enterprise/cache/stats", tags=["Enterprise Monitoring"])
async def get_enterprise_cache_stats(api_key: str = Depends(get_api_key)):
   """‚úÖ ENTERPRISE: Get comprehensive cache statistics"""
   try:
       product_cache = await get_enterprise_product_cache()
       cache_stats = product_cache.get_stats()
       
       redis_service = await ServiceFactory.get_redis_service()
       redis_health = await redis_service.health_check()
       
       return {
           "timestamp": time.time(),
           "service": "enterprise_cache_monitoring",
           "cache_stats": cache_stats,
           "redis_health": redis_health,
           "enterprise_metadata": {
               "architecture": "enterprise",
               "singleton_pattern": True,
               "connection_pooling": True
           }
       }
   except Exception as e:
       return {
           "timestamp": time.time(),
           "service": "enterprise_cache_monitoring",
           "error": str(e),
           "status": "degraded"
       }

@router.post("/enterprise/cache/warm-up", tags=["Enterprise Management"])
async def enterprise_cache_warmup(
   market_priorities: List[str] = Query(default=["US", "ES", "MX"]),
   max_products: int = Query(default=50, ge=1, le=200),
   api_key: str = Depends(get_api_key)
):
   """‚úÖ ENTERPRISE: Intelligent cache warm-up con enterprise patterns"""
   try:
       product_cache = await get_enterprise_product_cache()
       
       warmup_result = await product_cache.intelligent_cache_warmup(
           market_priorities=market_priorities,
           max_products_per_market=max_products
       )
       
       return {
           "timestamp": time.time(),
           "service": "enterprise_cache_warmup",
           "success": True,
           "warmup_result": warmup_result,
           "enterprise_metadata": {
               "architecture": "enterprise",
               "intelligent_warmup": True,
               "market_aware": True
           }
       }
   except Exception as e:
       return {
           "timestamp": time.time(),
           "service": "enterprise_cache_warmup",
           "success": False,
           "error": str(e)
       }

@router.get("/enterprise/performance/metrics", tags=["Enterprise Monitoring"])
async def get_enterprise_performance_metrics(api_key: str = Depends(get_api_key)):
   """‚úÖ ENTERPRISE: Get comprehensive performance metrics"""
   try:
       # Get cache performance
       product_cache = await get_enterprise_product_cache()
       cache_stats = product_cache.get_stats()
       
       # Get Redis performance
       redis_service = await ServiceFactory.get_redis_service()
       redis_health = await redis_service.health_check()
       
       # Get inventory service performance
       inventory_service = await get_enterprise_inventory_service()
       
       return {
           "timestamp": time.time(),
           "service": "enterprise_performance_monitoring",
           "performance_metrics": {
               "cache_performance": {
                   "hit_ratio": cache_stats.get("hit_ratio", 0),
                   "total_requests": cache_stats.get("total_requests", 0),
                   "cache_size": cache_stats.get("cache_size", 0),
                   "efficiency_rating": "excellent" if cache_stats.get("hit_ratio", 0) > 0.7 else "good" if cache_stats.get("hit_ratio", 0) > 0.4 else "needs_improvement"
               },
               "redis_performance": {
                   "status": redis_health.get("status"),
                   "response_time_ms": redis_health.get("response_time_ms"),
                   "connection_pool_active": redis_health.get("connection_pool", {}).get("active_connections", 0)
               },
               "overall_system_health": "optimal" if redis_health.get("status") == "healthy" and cache_stats.get("hit_ratio", 0) > 0.5 else "functional"
           },
           "enterprise_metadata": {
               "architecture": "enterprise",
               "monitoring_level": "comprehensive",
               "service_discovery": True
           }
       }
   except Exception as e:
       return {
           "timestamp": time.time(),
           "service": "enterprise_performance_monitoring",
           "error": str(e),
           "status": "monitoring_degraded"
       }

# ============================================================================
# üöÄ PRODUCTCACHE MANAGEMENT ENDPOINTS (ORIGINAL)
# ============================================================================

@router.get("/debug/product-cache", tags=["ProductCache"])
async def debug_product_cache():
   """Debug endpoint para ProductCache statistics (ORIGINAL)"""
   try:
       cache = await get_product_cache_dependency()
       
       if not cache:
           return {
               "timestamp": time.time(),
               "cache_available": False,
               "error": "ProductCache not initialized",
               "fallback_mode": True
           }
       
       stats = cache.get_stats()
       
       return {
           "timestamp": time.time(),
           "cache_available": True,
           "cache_stats": stats,
           "cache_health": "healthy" if stats["hit_ratio"] > 0.3 else "warming_up",
           "recommendations": {
               "warm_up_needed": stats["total_requests"] < 20,
               "hit_ratio_status": "excellent" if stats["hit_ratio"] > 0.7 else "good" if stats["hit_ratio"] > 0.4 else "needs_improvement"
           }
       }
   except Exception as e:
       return {
           "timestamp": time.time(),
           "cache_available": False,
           "error": str(e),
           "fallback_mode": True
       }

@router.post("/cache/warm-up", tags=["ProductCache"])
async def warm_up_product_cache(
   market_priorities: List[str] = Query(default=["US", "ES", "MX"], description="Markets to warm up"),
   max_products: int = Query(default=50, description="Max products per market"),
   api_key: str = Depends(get_api_key)
):
   """Warm up ProductCache intelligently (ORIGINAL)"""
   try:
       cache = await get_product_cache_dependency()
       
       if not cache:
           return {
               "success": False,
               "error": "ProductCache not available",
               "timestamp": time.time()
           }
       
       result = await cache.intelligent_cache_warmup(
           market_priorities=market_priorities,
           max_products_per_market=max_products
       )
       
       return {
           "success": True,
           "warm_up_result": result,
           "timestamp": time.time()
       }
       
   except Exception as e:
       return {
           "success": False,
           "error": str(e),
           "timestamp": time.time()
       }

# ============================================================================
# üîç DEBUG ENDPOINTS - TEMPORALES PARA DEBUGGING (ORIGINAL)
# ============================================================================

@router.get("/debug/shopify", tags=["Debug"])
async def debug_shopify_connection_endpoint():
   """Endpoint para debugging de conexi√≥n Shopify (ORIGINAL)"""
   shopify_client = get_shopify_client()
   return await debug_shopify_connection(shopify_client)

@router.get(
   "/debug/headers",
   summary="üîç Debug Headers",
   description="Endpoint temporal para debugging de headers de autenticaci√≥n",
   tags=["Debug"]
)
async def debug_headers(request: Request):
   """
   üîç Endpoint debug para investigar problemas de autenticaci√≥n (ORIGINAL).
   
   Este endpoint NO requiere autenticaci√≥n y muestra todos los headers
   recibidos para diagnosticar problemas con X-API-Key.
   """
   import time
   
   return {
       "timestamp": time.time(),
       "method": request.method,
       "url": str(request.url),
       "client_host": request.client.host if request.client else "unknown",
       "headers": {
           # Convertir headers a dict para JSON serialization
           key: value for key, value in request.headers.items()
       },
       "specific_headers": {
           "x_api_key": request.headers.get("X-API-Key"),
           "x_api_key_present": "X-API-Key" in request.headers,
           "authorization": request.headers.get("Authorization"),
           "content_type": request.headers.get("Content-Type"),
           "user_agent": request.headers.get("User-Agent"),
           "origin": request.headers.get("Origin"),
           "referer": request.headers.get("Referer")
       },
       "header_analysis": {
           "total_headers_count": len(request.headers),
           "x_api_key_length": len(request.headers.get("X-API-Key", "")),
           "expected_api_key": "2fed9999056fab6dac5654238f0cae1c",
           "api_key_matches": request.headers.get("X-API-Key") == "2fed9999056fab6dac5654238f0cae1c"
       }
   }

@router.get(
   "/debug/auth-test",
   summary="üîê Debug Auth Test",
   description="Endpoint que requiere autenticaci√≥n para testing",
   tags=["Debug"]
)
async def debug_auth_test(
   request: Request,
   api_key: str = Depends(get_api_key)
):
   """
   üîê Endpoint debug que S√ç requiere autenticaci√≥n (ORIGINAL).
   
   Si este endpoint funciona, significa que la autenticaci√≥n est√° OK.
   Si falla, podemos comparar con /debug/headers para ver qu√© cambi√≥.
   """
   import time
   
   return {
       "timestamp": time.time(),
       "status": "authenticated_successfully",
       "message": "‚úÖ Authentication working correctly!",
       "api_key_validated": api_key[:10] + "...",  # Solo primeros 10 chars por seguridad
       "headers_received": {
           key: value for key, value in request.headers.items()
       },
       "auth_flow": "Headers ‚Üí FastAPI ‚Üí APIKeyHeader ‚Üí get_api_key() ‚Üí SUCCESS"
   }

@router.get(
   "/debug/load-test",
   summary="üöÄ Debug Load Test",
   description="Endpoint optimizado para load testing debugging",
   tags=["Debug"]
)
async def debug_load_test(
   request: Request,
   api_key: str = Depends(get_api_key),
   test_id: Optional[str] = Query(None, description="ID del test para tracking")
):
   """
   üöÄ Endpoint espec√≠fico para debugging de load testing (ORIGINAL).
   
   Retorna informaci√≥n m√≠nima para reducir overhead durante tests de carga.
   """
   import time
   
   return {
       "test_id": test_id or "no_id",
       "timestamp": time.time(),
       "status": "ok",
       "auth": "valid",
       "api_key_prefix": api_key[:8],
       "response_time_start": time.time()
   }

# ============================================================================
# üîÑ LEGACY COMPATIBILITY ENDPOINTS (DEPRECATED)
# ============================================================================

@router.get("/legacy/products/", tags=["Legacy Compatibility"], deprecated=True)
async def get_products_legacy_compatibility(
   limit: int = Query(default=10, ge=1, le=100),
   page: int = Query(default=1, ge=1),
   market_id: str = Query(default="US"),
   api_key: str = Depends(get_api_key)
):
   """
   ‚ö†Ô∏è DEPRECATED: Legacy compatibility endpoint.
   Use /v1/products/ for enterprise architecture.
   """
   logger.warning("‚ö†Ô∏è DEPRECATED: Legacy products endpoint used - migrate to enterprise /v1/products/")
   
   # Redirect to enterprise endpoint internally
   return await get_products(
       limit=limit,
       page=page,
       market_id=market_id,
       include_inventory=True,
       category=None,
       available_only=False,
       api_key=api_key
   )