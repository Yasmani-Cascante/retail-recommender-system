# src/api/routers/products_router.py
"""
Products Router - Enterprise Architecture + Full Legacy Support
==============================================================

Router enterprise que mantiene TODA la funcionalidad original mientras
añade nuevos patrones enterprise. Garantiza zero breaking changes.

Author: Senior Architecture Team
Version: 2.1.0 - Enterprise Migration with Full Legacy Support
"""
import asyncio
import logging
import time
from typing import Dict, List, Optional, Any
from fastapi import APIRouter, Depends, HTTPException, Query, Request
from pydantic import BaseModel, Field

# Imports del sistema original (mantenidos)
from src.api.security_auth import get_api_key
from src.api.core.store import get_shopify_client
from src.api.inventory.inventory_service import InventoryService
from src.api.inventory.availability_checker import create_availability_checker

# ✅ ENTERPRISE IMPORTS - Centralized dependency injection
from src.api.factories import ServiceFactory, InfrastructureCompositionRoot, HealthCompositionRoot

# ✅ CORRECCIÓN CRÍTICA: Dependency injection unificada (ORIGINAL)
from src.api.core.redis_service import get_redis_service, RedisService
from src.api.core.product_cache import ProductCache
from src.api.core.redis_config_fix import PatchedRedisClient  # ✅ Añadir import faltante

logger = logging.getLogger(__name__)

# ============================================================================
# 📋 PYDANTIC MODELS - Response structures (ORIGINAL + ENTERPRISE)
# ============================================================================

class ProductResponse(BaseModel):
    """Modelo de respuesta para productos individuales"""
    id: str
    title: str
    description: Optional[str] = None
    price: Optional[float] = None
    currency: str = "USD"
    image_url: Optional[str] = None
    category: Optional[str] = None
    
    # Campos de inventario enterprise
    availability: str = "available"
    in_stock: bool = True
    stock_quantity: int = 0
    inventory_status: str = "available"
    market_availability: Dict[str, bool] = {}
    low_stock_warning: bool = False
    estimated_restock: Optional[str] = None
    inventory_last_updated: Optional[float] = None
    
    # Enterprise metadata
    cache_hit: bool = False
    service_version: str = "2.1.0"

class ProductListResponse(BaseModel):
    """Modelo de respuesta para lista de productos"""
    products: List[ProductResponse]
    total: int
    page: int
    limit: int
    has_next: bool
    market_id: str
    inventory_summary: Dict[str, Any] = {}
    
    # Enterprise metadata
    cache_stats: Dict[str, Any] = {}
    performance_metrics: Dict[str, float] = {}
    service_version: str = "2.1.0"

# ============================================================================
# 🏗️ SERVICE FACTORIES - Enterprise + Legacy Dependency Injection
# ============================================================================

# Variables globales para servicios (LEGACY - mantener durante transición)
_inventory_service: Optional[InventoryService] = None
_availability_checker = None
_product_cache: Optional[ProductCache] = None

# ✅ ENTERPRISE DEPENDENCY INJECTION
async def get_enterprise_inventory_service():
    """✅ ENTERPRISE: Dependency injection para InventoryService"""
    try:
        inventory_service = await ServiceFactory.get_inventory_service_singleton()
        logger.debug("✅ Enterprise InventoryService singleton acquired")
        return inventory_service
    except Exception as e:
        logger.error(f"❌ Enterprise InventoryService failed: {e}")
        raise HTTPException(status_code=503, detail="Inventory service temporarily unavailable")

async def get_enterprise_product_cache():
    """✅ ENTERPRISE: Dependency injection para ProductCache"""
    try:
        product_cache = await ServiceFactory.get_product_cache_singleton()
        logger.debug("✅ Enterprise ProductCache singleton acquired")
        return product_cache
    except Exception as e:
        logger.error(f"❌ Enterprise ProductCache failed: {e}")
        raise HTTPException(status_code=503, detail="Product cache service temporarily unavailable")

async def get_enterprise_availability_checker():
    """✅ ENTERPRISE: Dependency injection para AvailabilityChecker"""
    try:
        availability_checker = await ServiceFactory.create_availability_checker()
        logger.debug("✅ Enterprise AvailabilityChecker created")
        return availability_checker
    except Exception as e:
        logger.error(f"❌ Enterprise AvailabilityChecker failed: {e}")
        raise HTTPException(status_code=503, detail="Availability checker service temporarily unavailable")

# ============================================================================
# 🔧 LEGACY DEPENDENCY INJECTION (ORIGINAL - PRESERVED)
# ============================================================================

async def get_inventory_service_dependency() -> InventoryService:
    """
    ✅ FACTORY CORREGIDA: Dependency injection unificada (ORIGINAL)
    
    Utiliza RedisService enterprise-grade en lugar de múltiples clients.
    Garantiza consistencia en connection management.
    """
    try:
        # ✅ Usar RedisService enterprise singleton
        redis_service = await get_redis_service()
        
        # ✅ Dependency injection limpia
        inventory_service = InventoryService(redis_service=redis_service)
        
        logger.info("✅ InventoryService initialized with RedisService enterprise")
        return inventory_service
        
    except Exception as e:
        logger.warning(f"⚠️ RedisService unavailable, InventoryService in fallback mode: {e}")
        
        # ✅ Graceful degradation
        inventory_service = InventoryService(redis_service=None)
        return inventory_service

async def get_product_cache_dependency() -> ProductCache:
    """
    ✅ FACTORY CORREGIDA: ProductCache con RedisService enterprise (ORIGINAL)
    
    Integra ProductCache con la nueva arquitectura Redis enterprise,
    manteniendo el hybrid fallback strategy.
    """
    try:
        # ✅ RedisService enterprise como fuente primaria
        redis_service = await get_redis_service()
        
        # ✅ Obtener dependencias adicionales
        shopify_client = get_shopify_client()
        
        # ✅ Inicializar ProductCache con arquitectura enterprise
        product_cache = ProductCache(
            redis_client=redis_service._client,  # Access to underlying client
            shopify_client=shopify_client,
            ttl_seconds=int(3600),  # 1 hour default
            prefix="product:v2:"
        )
        
        logger.info("✅ ProductCache initialized with RedisService enterprise architecture")
        return product_cache
        
    except Exception as e:
        logger.error(f"❌ ProductCache initialization failed: {e}")
        raise HTTPException(
            status_code=500, 
            detail="Product cache service unavailable"
        )

async def get_availability_checker_dependency():
    """✅ FACTORY CORREGIDA: AvailabilityChecker con dependency injection enterprise (ORIGINAL)"""
    inventory_service = await get_inventory_service_dependency()
    return create_availability_checker(inventory_service)

# ============================================================================
# 🔄 LEGACY COMPATIBILITY FUNCTIONS - Mantener durante transición (ORIGINAL)
# ============================================================================

def get_inventory_service() -> InventoryService:
    """
    ⚠️ LEGACY FUNCTION - DEPRECATED (ORIGINAL)
    
    Usar get_inventory_service_dependency() para nueva arquitectura enterprise.
    Esta función se mantiene solo para compatibilidad con código existente.
    """
    global _inventory_service
    if _inventory_service is None:
        logger.warning("⚠️ Using legacy get_inventory_service() - Consider migration to enterprise architecture")
        try:
            # Crear con configuración legacy (sin Redis)
            _inventory_service = InventoryService(redis_service=None)
            logger.info("✅ Legacy InventoryService created without Redis")
        except Exception as e:
            logger.error(f"❌ Error creating legacy InventoryService: {e}")
            # Crear instancia mínima como fallback
            _inventory_service = InventoryService(redis_service=None)
    
    return _inventory_service

def get_availability_checker():
    """⚠️ LEGACY FUNCTION - DEPRECATED (ORIGINAL)"""
    global _availability_checker
    if _availability_checker is None:
        logger.warning("⚠️ Using legacy get_availability_checker() - Consider migration to enterprise architecture")
        try:
            inventory_service = get_inventory_service()
            _availability_checker = create_availability_checker(inventory_service)
            logger.info("✅ Legacy AvailabilityChecker created")
        except Exception as e:
            logger.error(f"❌ Error creating legacy AvailabilityChecker: {e}")
            # Crear mock como fallback
            _availability_checker = type('MockChecker', (), {
                'check_availability': lambda self, *args, **kwargs: {'status': 'available', 'fallback': True}
            })()
    
    return _availability_checker

def get_product_cache() -> Optional[ProductCache]:
    """🚀 Factory para obtener ProductCache singleton - DEPRECATED (ORIGINAL)"""
    global _product_cache
    if _product_cache is None:
        try:
            # Obtener dependencias
            shopify_client = get_shopify_client()
            
            # Intentar usar Redis con configuración validada
            redis_client = None
            try:
                redis_client = PatchedRedisClient(use_validated_config=True)
                logger.info("✅ ProductCache legacy initialized with Redis validated")
            except Exception as e:
                redis_client = None
                logger.warning(f"Redis unavailable for ProductCache legacy: {e}")

            # Crear ProductCache con configuración legacy
            _product_cache = ProductCache(
                redis_client=redis_client,
                local_catalog=None,
                shopify_client=shopify_client,
                product_gateway=None,
                ttl_seconds=900,  # 15 minutos
                prefix="products_legacy:"
            )
            
            logger.info("✅ ProductCache legacy singleton created")
            
        except Exception as e:
            logger.error(f"❌ Error creating ProductCache legacy: {e}")
            _product_cache = None
            
    return _product_cache

# ============================================================================
# 🔥 ROUTER SETUP
# ============================================================================

router = APIRouter(prefix="/v1", tags=["Products"])

# ============================================================================
# 📊 HEALTH CHECK ENDPOINT - Enterprise Monitoring (ORIGINAL + ENHANCED)
# ============================================================================

@router.get("/products/health")
async def products_health_check():
    """Health check comprehensivo para el sistema de productos (ORIGINAL + ENHANCED)"""
    health_status = {
        "timestamp": time.time(),
        "service": "products_api",
        "version": "2.1.0",
        "components": {}
    }
    
    try:
        # ✅ Check RedisService health
        redis_service = await get_redis_service()
        redis_health = await redis_service.health_check()
        health_status["components"]["redis_service"] = redis_health
        
        # ✅ Check InventoryService health
        inventory_service = await get_inventory_service_dependency()
        health_status["components"]["inventory_service"] = {
            "status": "operational",
            "redis_integrated": inventory_service.redis_service is not None
        }
        
        # ✅ Check ProductCache health
        try:
            product_cache = await get_product_cache_dependency()
            cache_stats = product_cache.get_stats()
            health_status["components"]["product_cache"] = {
                "status": "operational",
                "stats": cache_stats
            }
        except Exception as cache_error:
            health_status["components"]["product_cache"] = {
                "status": "degraded",
                "error": str(cache_error)
            }
        
        # ✅ Determine overall status
        component_statuses = [
            comp.get("status", "unknown") 
            for comp in health_status["components"].values()
        ]
        
        if all(status == "operational" for status in component_statuses):
            health_status["overall_status"] = "healthy"
        elif any(status == "operational" for status in component_statuses):
            health_status["overall_status"] = "degraded"
        else:
            health_status["overall_status"] = "unhealthy"
            
        return health_status
        
    except Exception as e:
        logger.error(f"❌ Products health check failed: {e}")
        health_status["overall_status"] = "unhealthy"
        health_status["error"] = str(e)
        return health_status

# ============================================================================
# 🛍️ MAIN PRODUCT ENDPOINTS (ORIGINAL PRESERVED + ENTERPRISE ENHANCED)
# ============================================================================

@router.get(
    "/products/",
    response_model=ProductListResponse,
    summary="Obtener lista de productos",
    description="Obtiene lista paginada de productos con información de inventario incluida"
)
async def get_products(
    limit: int = Query(default=10, ge=1, le=100, description="Número máximo de productos a retornar"),
    page: int = Query(default=1, ge=1, description="Página de resultados"),
    market_id: str = Query(default="US", description="ID del mercado para verificar disponibilidad"),
    include_inventory: bool = Query(default=True, description="Incluir información de inventario"),
    category: Optional[str] = Query(default=None, description="Filtrar por categoría"),
    available_only: bool = Query(default=False, description="Solo productos disponibles"),
    api_key: str = Depends(get_api_key)
):
    """
    Obtener lista de productos con información de inventario (ORIGINAL + ENHANCED).
    
    Este endpoint:
    1. Obtiene productos desde Shopify
    2. Enriquece con información de inventario
    3. Filtra por disponibilidad si se requiere
    4. Retorna resultados paginados
    """
    try:
        start_time = time.time()
        logger.info(f"Getting products: limit={limit}, page={page}, market={market_id}")
        
        # 1. Obtener productos desde Shopify
        shopify_client = get_shopify_client()
        if not shopify_client:
            # Fallback con productos simulados si no hay Shopify
            products = await _get_sample_products(limit, page)
        else:
            # Calcular offset para paginación
            offset = (page - 1) * limit
            products = await _get_shopify_products(shopify_client, limit, offset, category)
        
        if not products:
            return ProductListResponse(
                products=[],
                total=0,
                page=page,
                limit=limit,
                has_next=False,
                market_id=market_id,
                inventory_summary={}
            )
        
        # 2. Enriquecer con información de inventario si se requiere
        if include_inventory:
            inventory_service = get_inventory_service()
            enriched_products = await inventory_service.enrich_products_with_inventory(
                products, market_id
            )
        else:
            enriched_products = products
        
        # 3. Filtrar por disponibilidad si se requiere
        if available_only:
            availability_checker = get_availability_checker()
            enriched_products = await availability_checker.filter_available_products(
                enriched_products, market_id
            )
        
        # 4. Convertir a modelos de respuesta
        product_responses = []
        for product in enriched_products[:limit]:  # Asegurar límite
            try:
                product_response = ProductResponse(
                    id=str(product.get("id", "")),
                    title=product.get("title", ""),
                    description=product.get("description", ""),
                    price=float(product.get("price", 0)) if product.get("price") else None,
                    currency=product.get("currency", "USD"),
                    image_url=product.get("image_url") or product.get("featured_image"),
                    category=product.get("category") or product.get("product_type"),
                    
                    # Campos de inventario
                    availability=product.get("availability", "available"),
                    in_stock=product.get("in_stock", True),
                    stock_quantity=product.get("stock_quantity", 10),
                    inventory_status=product.get("inventory_status", "available"),
                    market_availability=product.get("market_availability", {market_id: True}),
                    low_stock_warning=product.get("low_stock_warning", False),
                    estimated_restock=product.get("estimated_restock"),
                    inventory_last_updated=product.get("inventory_last_updated")
                )
                product_responses.append(product_response)
            except Exception as e:
                logger.warning(f"Error processing product {product.get('id')}: {e}")
                continue
        
        # 5. Generar resumen de inventario
        inventory_summary = {}
        if include_inventory and product_responses:
            inventory_service = get_inventory_service()
            # Crear diccionario de inventario para el resumen
            inventory_dict = {
                p.id: type('InventoryInfo', (), {
                    'status': type('Status', (), {'value': p.inventory_status})(),
                    'available_quantity': p.stock_quantity
                })()
                for p in product_responses
            }
            inventory_summary = inventory_service.get_market_availability_summary(inventory_dict)
        
        # 6. Determinar si hay página siguiente
        has_next = len(enriched_products) > limit
        
        # 7. Crear respuesta final
        response = ProductListResponse(
            products=product_responses,
            total=len(product_responses),
            page=page,
            limit=limit,
            has_next=has_next,
            market_id=market_id,
            inventory_summary=inventory_summary
        )
        
        execution_time = (time.time() - start_time) * 1000
        logger.info(f"✅ Products endpoint: {len(product_responses)} products, {execution_time:.1f}ms")
        
        return response
        
    except Exception as e:
        logger.error(f"Error in get_products: {e}")
        raise HTTPException(
            status_code=500,
            detail=f"Error retrieving products: {str(e)}"
        )

@router.get(
    "/products/{product_id}",
    response_model=ProductResponse,
    summary="Obtener producto específico",
    description="Obtiene información detallada de un producto específico con datos de inventario"
)
async def get_product(
    product_id: str,
    market_id: str = Query(default="US", description="ID del mercado"),
    include_inventory: bool = Query(default=True, description="Incluir información de inventario"),
    api_key: str = Depends(get_api_key)
):
    """Obtener información detallada de un producto específico (ORIGINAL)."""
    try:
        logger.info(f"Getting product {product_id} for market {market_id}")
        
        # 1. Obtener producto desde Shopify
        shopify_client = get_shopify_client()
        if not shopify_client:
            # Fallback con producto simulado
            product = await _get_sample_product(product_id)
        else:
            product = await _get_shopify_product(shopify_client, product_id)
        
        if not product:
            raise HTTPException(
                status_code=404,
                detail=f"Product {product_id} not found"
            )
        
        # 2. Enriquecer con información de inventario
        if include_inventory:
            inventory_service = get_inventory_service()
            enriched_products = await inventory_service.enrich_products_with_inventory(
                [product], market_id
            )
            enriched_product = enriched_products[0] if enriched_products else product
        else:
            enriched_product = product
        
        # 3. Crear respuesta
        product_response = ProductResponse(
            id=str(enriched_product.get("id", product_id)),
            title=enriched_product.get("title", ""),
            description=enriched_product.get("description", ""),
            price=float(enriched_product.get("price", 0)) if enriched_product.get("price") else None,
            currency=enriched_product.get("currency", "USD"),
            image_url=enriched_product.get("image_url") or enriched_product.get("featured_image"),
            category=enriched_product.get("category") or enriched_product.get("product_type"),
            
            # Campos de inventario
            availability=enriched_product.get("availability", "available"),
            in_stock=enriched_product.get("in_stock", True),
            stock_quantity=enriched_product.get("stock_quantity", 10),
            inventory_status=enriched_product.get("inventory_status", "available"),
            market_availability=enriched_product.get("market_availability", {market_id: True}),
            low_stock_warning=enriched_product.get("low_stock_warning", False),
            estimated_restock=enriched_product.get("estimated_restock"),
            inventory_last_updated=enriched_product.get("inventory_last_updated")
        )
        
        logger.info(f"✅ Product {product_id}: {product_response.availability}")
        return product_response
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error getting product {product_id}: {e}")
        raise HTTPException(
            status_code=500,
            detail=f"Error retrieving product: {str(e)}"
        )

# ============================================================================
# 🔧 FUNCIONES HELPER PARA OBTENER PRODUCTOS (ORIGINAL PRESERVED)
# ============================================================================

async def _get_shopify_products(
    shopify_client, 
    limit: int, 
    offset: int = 0, 
    category: Optional[str] = None
) -> List[Dict]:
    """
    🚀 UPGRADED: Obtener productos usando ProductCache avanzado con market awareness (ORIGINAL + ENHANCED)
    """
    try:
        start_time = time.time()
        cache = await get_product_cache_dependency()
        
        if not cache:
            # Fallback a shopify directo si ProductCache no está disponible
            logger.warning("⚠️ ProductCache not available, falling back to direct Shopify")
            return await _get_shopify_products_direct(shopify_client, limit, offset, category)
        
        # Calcular página para ProductCache
        page = (offset // limit) + 1
        market_id = "US"  # Default, podría extraerse del contexto
        
        logger.info(f"🚀 UPGRADED: Obteniendo productos con ProductCache - limit={limit}, page={page}, market={market_id}")
        
        # Estrategia 1: Intentar obtener productos populares del mercado
        try:
            popular_products = await cache.get_popular_products(market_id, limit * 2)
            if popular_products:
                cached_products = []
                for product_id in popular_products[:limit]:
                    product = await cache.get_product(product_id)
                    if product:
                        # Filtrar por categoría si se especifica
                        if not category or product.get("category") == category or product.get("product_type") == category:
                            cached_products.append(product)
                        
                        if len(cached_products) >= limit:
                            break
                
                if len(cached_products) >= limit // 2:
                    response_time = (time.time() - start_time) * 1000
                    logger.info(f"✅ ProductCache hit: {len(cached_products)} productos en {response_time:.1f}ms")
                    return cached_products[:limit]
        
        except Exception as e:
            logger.warning(f"⚠️ Popular products strategy failed: {e}")
        
        # Estrategia 2: Fallback a Shopify con ProductCache
        if shopify_client:
            products = await _get_shopify_products_direct(shopify_client, limit, offset, category)
           
            # Precargar productos en cache de forma asíncrona
            if products:
                product_ids = [str(p.get("id", "")) for p in products if p.get("id")]
                if product_ids:
                    logger.info(f"Pre-cargando en el router {len(product_ids)} en Estrategia 2 ")
                    asyncio.create_task(cache.preload_products(product_ids[:10]))
            
            response_time = (time.time() - start_time) * 1000
            logger.info(f"✅ UPGRADED: Productos obtenidos en {response_time:.1f}ms - {len(products)} productos")
            return products
        
        else:
            # Estrategia 3: Productos de muestra
            return await _get_sample_products(limit, page, category)
        
    except Exception as e:
        response_time = (time.time() - start_time) * 1000
        logger.error(f"❌ UPGRADED: Error después de {response_time:.1f}ms: {e}")
        return await _get_sample_products(limit, offset // limit + 1, category)

async def _get_shopify_products_direct(
    shopify_client, 
    limit: int, 
    offset: int = 0, 
    category: Optional[str] = None
) -> List[Dict]:
    """Obtener productos directamente de Shopify (mantiene lógica original) (ORIGINAL)"""
    try:
        if not shopify_client:
            return await _get_sample_products(limit, offset // limit + 1, category)
        
        start_time = time.time()
        
        def fetch_shopify_sync():
            try:
                all_shopify_products = shopify_client.get_products(limit=limit*2, offset=offset)
                if not all_shopify_products:
                    return []
                
                normalized_products = []
                for shopify_product in all_shopify_products:
                    try:
                        variants = shopify_product.get('variants', [])
                        first_variant = variants[0] if variants else {}
                        images = shopify_product.get('images', [])
                        image_url = images[0].get('src') if images else None
                        
                        normalized_product = {
                            "id": str(shopify_product.get('id')),
                            "title": shopify_product.get('title', ''),
                            "description": shopify_product.get('body_html', ''),
                            "price": float(first_variant.get('price', 0)) if first_variant.get('price') else 0.0,
                            "currency": "USD",
                            "featured_image": image_url,
                            "image_url": image_url,
                            "product_type": shopify_product.get('product_type', ''),
                            "category": shopify_product.get('product_type', ''),
                            "vendor": shopify_product.get('vendor', ''),
                            "handle": shopify_product.get('handle', ''),
                            "sku": first_variant.get('sku', ''),
                            "inventory_quantity": first_variant.get('inventory_quantity', 0),
                        }
                        
                        normalized_products.append(normalized_product)
                        
                    except Exception as e:
                        logger.warning(f"⚠️ Error normalizing product: {e}")
                        continue
                
                return normalized_products
                
            except Exception as e:
                logger.error(f"❌ Error fetching from Shopify: {e}")
                return []
        
        # Ejecutar en thread pool con timeout dinámico
        # Timeout más corto para requests pequeños, más largo para grandes
        dynamic_timeout = 5.0 if limit <= 10 else 15.0 if limit <= 50 else 30.0
        
        products = await asyncio.wait_for(
            asyncio.to_thread(fetch_shopify_sync),
            timeout=dynamic_timeout
        )
        
        if products:
            # Filtrar por categoría
            if category:
                products = [
                    p for p in products 
                    if p.get("category", "").lower() == category.lower() or 
                       p.get("product_type", "").lower() == category.lower()
                ]
            
            # Aplicar paginación
            start_idx = offset
            end_idx = start_idx + limit
            paginated_products = products[start_idx:end_idx]
            
            response_time = (time.time() - start_time) * 1000
            logger.info(f"✅ Shopify direct: {len(paginated_products)} productos en {response_time:.1f}ms")
            logger.info(f"   Request efficiency: {len(paginated_products)}/{len(products)} productos utilizados")
            
            return paginated_products
        
        else:
            return await _get_sample_products(limit, offset // limit + 1, category)
    
    except asyncio.TimeoutError:
        logger.error("❌ Shopify timeout - using fallback")
        return await _get_sample_products(limit, offset // limit + 1, category)
    except Exception as e:
        logger.error(f"❌ Error in Shopify direct: {e}")
        return await _get_sample_products(limit, offset // limit + 1, category)

async def _get_sample_products(limit: int, page: int = 1, category: Optional[str] = None) -> List[Dict]:
    """Generar productos de ejemplo para testing (ORIGINAL)"""
    products = [
        {
            "id": f"prod_{i:03d}",
            "title": f"Producto Ejemplo {i}",
            "description": f"Descripción del producto ejemplo número {i}",
            "price": 25.99 + (i * 5.0),
            "currency": "USD",
            "featured_image": f"https://example.com/image_{i}.jpg",
            "product_type": "clothing" if i % 2 == 0 else "accessories",
            "category": "clothing" if i % 2 == 0 else "accessories"
        }
        for i in range(1, 51)  # 50 productos de ejemplo
    ]
    
    # Filtrar por categoría si se especifica
    if category:
        products = [p for p in products if p.get("category") == category]
    
    # Paginación
    start_idx = (page - 1) * limit
    end_idx = start_idx + limit
    
    return products[start_idx:end_idx]

async def _get_sample_product(product_id: str) -> Optional[Dict]:
    """Obtener producto de ejemplo específico (ORIGINAL)"""
    try:
        # Extraer número del ID
        if product_id.startswith("prod_"):
            num = int(product_id.split("_")[1])
        else:
            num = 1
        
        return {
            "id": product_id,
            "title": f"Producto Ejemplo {num}",
            "description": f"Descripción detallada del producto ejemplo número {num}",
            "price": 25.99 + (num * 5.0),
            "currency": "USD",
            "featured_image": f"https://example.com/image_{num}.jpg",
            "product_type": "clothing" if num % 2 == 0 else "accessories",
            "category": "clothing" if num % 2 == 0 else "accessories",
       }
    except:
       return {
           "id": product_id,
           "title": "Producto Ejemplo",
           "description": "Descripción de ejemplo",
           "price": 29.99,
           "currency": "USD",
           "featured_image": "https://example.com/image.jpg",
           "product_type": "clothing",
           "category": "clothing"
       }
   
async def _get_shopify_product(shopify_client, product_id: str) -> Optional[Dict]:
   """
   Obtener producto específico REAL desde Shopify (ORIGINAL)
   
   Esta función busca un producto específico por ID en los productos de Shopify
   """
   try:
       logger.info(f"🔍 Buscando producto específico ID: {product_id}")
       
       # Obtener todos los productos (en un sistema real, usarías el endpoint específico)
       all_products = shopify_client.get_products()
       
       if not all_products:
           logger.warning("⚠️ No se obtuvieron productos de Shopify")
           return await _get_sample_product(product_id)
       
       # Buscar el producto específico
       for shopify_product in all_products:
           if str(shopify_product.get('id')) == str(product_id):
               logger.info(f"✅ Producto encontrado: {shopify_product.get('title')}")
               
               # Normalizar el producto (misma lógica que _get_shopify_products)
               variants = shopify_product.get('variants', [])
               first_variant = variants[0] if variants else {}
               images = shopify_product.get('images', [])
               image_url = images[0].get('src') if images else None
               
               return {
                   "id": str(shopify_product.get('id')),
                   "title": shopify_product.get('title', ''),
                   "description": shopify_product.get('body_html', ''),
                   "price": float(first_variant.get('price', 0)) if first_variant.get('price') else 0.0,
                   "currency": "USD",
                   "featured_image": image_url,
                   "image_url": image_url,
                   "product_type": shopify_product.get('product_type', ''),
                   "category": shopify_product.get('product_type', ''),
                   "vendor": shopify_product.get('vendor', ''),
                   "handle": shopify_product.get('handle', ''),
                   "sku": first_variant.get('sku', ''),
                   "inventory_quantity": first_variant.get('inventory_quantity', 0),
               }
       
       # Si no se encuentra el producto
       logger.warning(f"⚠️ Producto ID {product_id} no encontrado en Shopify")
       return await _get_sample_product(product_id)
       
   except Exception as e:
       logger.error(f"❌ Error obteniendo producto {product_id} de Shopify: {e}")
       return await _get_sample_product(product_id)

# ============================================================================
# 🔧 HELPER FUNCTIONS (ORIGINAL PRESERVED)
# ============================================================================

async def debug_shopify_connection(shopify_client) -> Dict:
   """
   Función de debugging para verificar la conexión con Shopify (ORIGINAL)
   """
   try:
       if not shopify_client:
           return {
               "status": "error",
               "message": "Shopify client no disponible",
               "details": "El cliente de Shopify no fue inicializado correctamente"
           }
       
       # Intentar obtener el conteo de productos
       product_count = shopify_client.get_product_count()
       
       # Intentar obtener una muestra pequeña de productos
       sample_products = shopify_client.get_products()
       
       return {
           "status": "success",
           "message": "Conexión con Shopify exitosa",
           "details": {
               "shop_url": shopify_client.shop_url,
               "api_url": shopify_client.api_url,
               "product_count": product_count,
               "sample_products_fetched": len(sample_products) if sample_products else 0,
               "first_product_title": sample_products[0].get('title') if sample_products else None,
               "access_token_prefix": shopify_client.access_token[:4] + "..." if shopify_client.access_token else "No token"
           }
       }
       
   except Exception as e:
       return {
           "status": "error",
           "message": f"Error conectando con Shopify: {str(e)}",
           "details": {
               "shop_url": shopify_client.shop_url if shopify_client else "No client",
               "error_type": type(e).__name__
           }
       }

# ============================================================================
# 📊 ENTERPRISE MONITORING ENDPOINTS
# ============================================================================

@router.get("/enterprise/cache/stats", tags=["Enterprise Monitoring"])
async def get_enterprise_cache_stats(api_key: str = Depends(get_api_key)):
   """✅ ENTERPRISE: Get comprehensive cache statistics"""
   try:
       product_cache = await get_enterprise_product_cache()
       cache_stats = product_cache.get_stats()
       
       redis_service = await ServiceFactory.get_redis_service()
       redis_health = await redis_service.health_check()
       
       return {
           "timestamp": time.time(),
           "service": "enterprise_cache_monitoring",
           "cache_stats": cache_stats,
           "redis_health": redis_health,
           "enterprise_metadata": {
               "architecture": "enterprise",
               "singleton_pattern": True,
               "connection_pooling": True
           }
       }
   except Exception as e:
       return {
           "timestamp": time.time(),
           "service": "enterprise_cache_monitoring",
           "error": str(e),
           "status": "degraded"
       }

@router.post("/enterprise/cache/warm-up", tags=["Enterprise Management"])
async def enterprise_cache_warmup(
   market_priorities: List[str] = Query(default=["US", "ES", "MX"]),
   max_products: int = Query(default=50, ge=1, le=200),
   api_key: str = Depends(get_api_key)
):
   """✅ ENTERPRISE: Intelligent cache warm-up con enterprise patterns"""
   try:
       product_cache = await get_enterprise_product_cache()
       
       warmup_result = await product_cache.intelligent_cache_warmup(
           market_priorities=market_priorities,
           max_products_per_market=max_products
       )
       
       return {
           "timestamp": time.time(),
           "service": "enterprise_cache_warmup",
           "success": True,
           "warmup_result": warmup_result,
           "enterprise_metadata": {
               "architecture": "enterprise",
               "intelligent_warmup": True,
               "market_aware": True
           }
       }
   except Exception as e:
       return {
           "timestamp": time.time(),
           "service": "enterprise_cache_warmup",
           "success": False,
           "error": str(e)
       }

@router.get("/enterprise/performance/metrics", tags=["Enterprise Monitoring"])
async def get_enterprise_performance_metrics(api_key: str = Depends(get_api_key)):
   """✅ ENTERPRISE: Get comprehensive performance metrics"""
   try:
       # Get cache performance
       product_cache = await get_enterprise_product_cache()
       cache_stats = product_cache.get_stats()
       
       # Get Redis performance
       redis_service = await ServiceFactory.get_redis_service()
       redis_health = await redis_service.health_check()
       
       # Get inventory service performance
       inventory_service = await get_enterprise_inventory_service()
       
       return {
           "timestamp": time.time(),
           "service": "enterprise_performance_monitoring",
           "performance_metrics": {
               "cache_performance": {
                   "hit_ratio": cache_stats.get("hit_ratio", 0),
                   "total_requests": cache_stats.get("total_requests", 0),
                   "cache_size": cache_stats.get("cache_size", 0),
                   "efficiency_rating": "excellent" if cache_stats.get("hit_ratio", 0) > 0.7 else "good" if cache_stats.get("hit_ratio", 0) > 0.4 else "needs_improvement"
               },
               "redis_performance": {
                   "status": redis_health.get("status"),
                   "response_time_ms": redis_health.get("response_time_ms"),
                   "connection_pool_active": redis_health.get("connection_pool", {}).get("active_connections", 0)
               },
               "overall_system_health": "optimal" if redis_health.get("status") == "healthy" and cache_stats.get("hit_ratio", 0) > 0.5 else "functional"
           },
           "enterprise_metadata": {
               "architecture": "enterprise",
               "monitoring_level": "comprehensive",
               "service_discovery": True
           }
       }
   except Exception as e:
       return {
           "timestamp": time.time(),
           "service": "enterprise_performance_monitoring",
           "error": str(e),
           "status": "monitoring_degraded"
       }

# ============================================================================
# 🚀 PRODUCTCACHE MANAGEMENT ENDPOINTS (ORIGINAL)
# ============================================================================

@router.get("/debug/product-cache", tags=["ProductCache"])
async def debug_product_cache():
   """Debug endpoint para ProductCache statistics (ORIGINAL)"""
   try:
       cache = await get_product_cache_dependency()
       
       if not cache:
           return {
               "timestamp": time.time(),
               "cache_available": False,
               "error": "ProductCache not initialized",
               "fallback_mode": True
           }
       
       stats = cache.get_stats()
       
       return {
           "timestamp": time.time(),
           "cache_available": True,
           "cache_stats": stats,
           "cache_health": "healthy" if stats["hit_ratio"] > 0.3 else "warming_up",
           "recommendations": {
               "warm_up_needed": stats["total_requests"] < 20,
               "hit_ratio_status": "excellent" if stats["hit_ratio"] > 0.7 else "good" if stats["hit_ratio"] > 0.4 else "needs_improvement"
           }
       }
   except Exception as e:
       return {
           "timestamp": time.time(),
           "cache_available": False,
           "error": str(e),
           "fallback_mode": True
       }

@router.post("/cache/warm-up", tags=["ProductCache"])
async def warm_up_product_cache(
   market_priorities: List[str] = Query(default=["US", "ES", "MX"], description="Markets to warm up"),
   max_products: int = Query(default=50, description="Max products per market"),
   api_key: str = Depends(get_api_key)
):
   """Warm up ProductCache intelligently (ORIGINAL)"""
   try:
       cache = await get_product_cache_dependency()
       
       if not cache:
           return {
               "success": False,
               "error": "ProductCache not available",
               "timestamp": time.time()
           }
       
       result = await cache.intelligent_cache_warmup(
           market_priorities=market_priorities,
           max_products_per_market=max_products
       )
       
       return {
           "success": True,
           "warm_up_result": result,
           "timestamp": time.time()
       }
       
   except Exception as e:
       return {
           "success": False,
           "error": str(e),
           "timestamp": time.time()
       }

# ============================================================================
# 🔍 DEBUG ENDPOINTS - TEMPORALES PARA DEBUGGING (ORIGINAL)
# ============================================================================

@router.get("/debug/shopify", tags=["Debug"])
async def debug_shopify_connection_endpoint():
   """Endpoint para debugging de conexión Shopify (ORIGINAL)"""
   shopify_client = get_shopify_client()
   return await debug_shopify_connection(shopify_client)

@router.get(
   "/debug/headers",
   summary="🔍 Debug Headers",
   description="Endpoint temporal para debugging de headers de autenticación",
   tags=["Debug"]
)
async def debug_headers(request: Request):
   """
   🔍 Endpoint debug para investigar problemas de autenticación (ORIGINAL).
   
   Este endpoint NO requiere autenticación y muestra todos los headers
   recibidos para diagnosticar problemas con X-API-Key.
   """
   import time
   
   return {
       "timestamp": time.time(),
       "method": request.method,
       "url": str(request.url),
       "client_host": request.client.host if request.client else "unknown",
       "headers": {
           # Convertir headers a dict para JSON serialization
           key: value for key, value in request.headers.items()
       },
       "specific_headers": {
           "x_api_key": request.headers.get("X-API-Key"),
           "x_api_key_present": "X-API-Key" in request.headers,
           "authorization": request.headers.get("Authorization"),
           "content_type": request.headers.get("Content-Type"),
           "user_agent": request.headers.get("User-Agent"),
           "origin": request.headers.get("Origin"),
           "referer": request.headers.get("Referer")
       },
       "header_analysis": {
           "total_headers_count": len(request.headers),
           "x_api_key_length": len(request.headers.get("X-API-Key", "")),
           "expected_api_key": "2fed9999056fab6dac5654238f0cae1c",
           "api_key_matches": request.headers.get("X-API-Key") == "2fed9999056fab6dac5654238f0cae1c"
       }
   }

@router.get(
   "/debug/auth-test",
   summary="🔐 Debug Auth Test",
   description="Endpoint que requiere autenticación para testing",
   tags=["Debug"]
)
async def debug_auth_test(
   request: Request,
   api_key: str = Depends(get_api_key)
):
   """
   🔐 Endpoint debug que SÍ requiere autenticación (ORIGINAL).
   
   Si este endpoint funciona, significa que la autenticación está OK.
   Si falla, podemos comparar con /debug/headers para ver qué cambió.
   """
   import time
   
   return {
       "timestamp": time.time(),
       "status": "authenticated_successfully",
       "message": "✅ Authentication working correctly!",
       "api_key_validated": api_key[:10] + "...",  # Solo primeros 10 chars por seguridad
       "headers_received": {
           key: value for key, value in request.headers.items()
       },
       "auth_flow": "Headers → FastAPI → APIKeyHeader → get_api_key() → SUCCESS"
   }

@router.get(
   "/debug/load-test",
   summary="🚀 Debug Load Test",
   description="Endpoint optimizado para load testing debugging",
   tags=["Debug"]
)
async def debug_load_test(
   request: Request,
   api_key: str = Depends(get_api_key),
   test_id: Optional[str] = Query(None, description="ID del test para tracking")
):
   """
   🚀 Endpoint específico para debugging de load testing (ORIGINAL).
   
   Retorna información mínima para reducir overhead durante tests de carga.
   """
   import time
   
   return {
       "test_id": test_id or "no_id",
       "timestamp": time.time(),
       "status": "ok",
       "auth": "valid",
       "api_key_prefix": api_key[:8],
       "response_time_start": time.time()
   }

# ============================================================================
# 🔄 LEGACY COMPATIBILITY ENDPOINTS (DEPRECATED)
# ============================================================================

@router.get("/legacy/products/", tags=["Legacy Compatibility"], deprecated=True)
async def get_products_legacy_compatibility(
   limit: int = Query(default=10, ge=1, le=100),
   page: int = Query(default=1, ge=1),
   market_id: str = Query(default="US"),
   api_key: str = Depends(get_api_key)
):
   """
   ⚠️ DEPRECATED: Legacy compatibility endpoint.
   Use /v1/products/ for enterprise architecture.
   """
   logger.warning("⚠️ DEPRECATED: Legacy products endpoint used - migrate to enterprise /v1/products/")
   
   # Redirect to enterprise endpoint internally
   return await get_products(
       limit=limit,
       page=page,
       market_id=market_id,
       include_inventory=True,
       category=None,
       available_only=False,
       api_key=api_key
   )