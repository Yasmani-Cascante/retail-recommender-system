# src/api/inventory/inventory_service.py
"""
Inventory Service - Gesti√≥n de Disponibilidad de Productos
==========================================================

Servicio principal para verificar y gestionar la disponibilidad de productos
en diferentes mercados, integrando con Shopify y otros proveedores.

Author: Technical Team
Version: 1.0.0
"""

import asyncio
import time
import logging
from typing import Dict, List, Optional, Any, Union
from dataclasses import dataclass
from enum import Enum
import json
from datetime import datetime, timedelta

# Imports para integraci√≥n
# from src.api.core.redis_client import RedisClient
from src.api.core.redis_config_fix import PatchedRedisClient as RedisClient
from src.api.core.store import get_shopify_client

logger = logging.getLogger(__name__)

class InventoryStatus(str, Enum):
    """Estados de disponibilidad de inventario"""
    AVAILABLE = "available"
    LOW_STOCK = "low_stock"
    OUT_OF_STOCK = "out_of_stock"
    BACKORDERED = "backordered"
    DISCONTINUED = "discontinued"
    UNKNOWN = "unknown"

@dataclass
class InventoryInfo:
    """Informaci√≥n completa de inventario para un producto"""
    product_id: str
    status: InventoryStatus
    quantity: int
    reserved_quantity: int = 0
    available_quantity: int = 0
    low_stock_threshold: int = 5
    market_availability: Dict[str, bool] = None
    supplier_info: Dict[str, Any] = None
    last_updated: float = None
    estimated_restock_date: Optional[str] = None
    
    def __post_init__(self):
        if self.market_availability is None:
            self.market_availability = {}
        if self.supplier_info is None:
            self.supplier_info = {}
        if self.last_updated is None:
            self.last_updated = time.time()
        
        # Calcular cantidad disponible
        self.available_quantity = max(0, self.quantity - self.reserved_quantity)
        
        # Determinar status basado en cantidad
        if self.available_quantity == 0:
            self.status = InventoryStatus.OUT_OF_STOCK
        elif self.available_quantity <= self.low_stock_threshold:
            self.status = InventoryStatus.LOW_STOCK
        else:
            self.status = InventoryStatus.AVAILABLE

class InventoryService:
    """
    Servicio principal de gesti√≥n de inventario que integra m√∫ltiples fuentes
    """
    
    def __init__(self, redis_client: Optional[RedisClient] = None):
        self.redis = redis_client
        self.shopify_client = None
        
        # Configuraci√≥n de cache
        self.CACHE_PREFIX = "inventory:product"
        self.MARKET_CACHE_PREFIX = "inventory:market"
        self.CACHE_TTL = 300  # 5 minutos para datos de inventario
        self.FALLBACK_TTL = 3600  # 1 hora para fallbacks
        
        # Configuraci√≥n por mercado
        self.market_configs = {
            "US": {
                "default_availability": True,
                "low_stock_threshold": 10,
                "currency": "USD"
            },
            "ES": {
                "default_availability": True,
                "low_stock_threshold": 5,
                "currency": "EUR"
            },
            "MX": {
                "default_availability": True,
                "low_stock_threshold": 8,
                "currency": "MXN"
            }
        }
        
        logger.info("üè™ InventoryService initialized")
    
    async def check_product_availability(
        self, 
        product_id: str, 
        market_id: str = "US"
    ) -> InventoryInfo:
        """
        Verificar disponibilidad de un producto espec√≠fico en un mercado.
        
        Args:
            product_id: ID del producto a verificar
            market_id: Mercado donde verificar disponibilidad
            
        Returns:
            InventoryInfo con informaci√≥n completa de disponibilidad
        """
        try:
            # 1. Intentar obtener de cache primero
            cached_info = await self._get_cached_inventory(product_id, market_id)
            if cached_info:
                logger.debug(f"Cache hit for product {product_id} in market {market_id}")
                return cached_info
            
            # 2. Obtener datos de Shopify
            shopify_inventory = await self._get_shopify_inventory(product_id)
            
            # 3. Construir informaci√≥n de inventario
            inventory_info = await self._build_inventory_info(
                product_id, market_id, shopify_inventory
            )
            
            # 4. Cachear resultado
            await self._cache_inventory_info(inventory_info, market_id)
            
            logger.info(f"‚úÖ Inventory check for {product_id}: {inventory_info.status.value} ({inventory_info.available_quantity} units)")
            return inventory_info
            
        except Exception as e:
            logger.warning(f"Error checking inventory for {product_id}: {e}")
            # Fallback optimista
            return await self._create_fallback_inventory(product_id, market_id)
    
    async def check_multiple_products_availability(
        self,
        product_ids: List[str],
        market_id: str = "US"
    ) -> Dict[str, InventoryInfo]:
        """
        Verificar disponibilidad de m√∫ltiples productos en paralelo.
        
        Args:
            product_ids: Lista de IDs de productos
            market_id: Mercado donde verificar
            
        Returns:
            Diccionario con InventoryInfo por producto_id
        """
        try:
            # Ejecutar verificaciones en paralelo
            tasks = [
                self.check_product_availability(product_id, market_id)
                for product_id in product_ids
            ]
            
            results = await asyncio.gather(*tasks, return_exceptions=True)
            
            # Procesar resultados
            inventory_results = {}
            for i, result in enumerate(results):
                product_id = product_ids[i]
                
                if isinstance(result, Exception):
                    logger.warning(f"Error checking {product_id}: {result}")
                    inventory_results[product_id] = await self._create_fallback_inventory(product_id, market_id)
                else:
                    inventory_results[product_id] = result
            
            logger.info(f"‚úÖ Checked inventory for {len(product_ids)} products in market {market_id}")
            return inventory_results
            
        except Exception as e:
            logger.error(f"Error in bulk inventory check: {e}")
            # Fallback para todos los productos
            return {
                product_id: await self._create_fallback_inventory(product_id, market_id)
                for product_id in product_ids
            }
    
    async def enrich_products_with_inventory(
        self,
        products: List[Dict],
        market_id: str = "US"
    ) -> List[Dict]:
        """
        Enriquecer lista de productos con informaci√≥n de inventario.
        
        Args:
            products: Lista de productos a enriquecer
            market_id: Mercado para verificar disponibilidad
            
        Returns:
            Lista de productos con informaci√≥n de inventario a√±adida
        """
        try:
            # Extraer IDs de productos
            product_ids = [
                product.get("id") or product.get("product_id") 
                for product in products
                if product.get("id") or product.get("product_id")
            ]
            
            if not product_ids:
                logger.warning("No product IDs found for inventory enrichment")
                return products
            
            # Obtener informaci√≥n de inventario
            inventory_data = await self.check_multiple_products_availability(product_ids, market_id)
            
            # Enriquecer productos
            enriched_products = []
            for product in products:
                product_id = product.get("id") or product.get("product_id")
                
                if product_id and product_id in inventory_data:
                    inventory_info = inventory_data[product_id]
                    
                    # A√±adir campos de inventario al producto
                    enriched_product = product.copy()
                    enriched_product.update({
                        "availability": inventory_info.status.value,
                        "in_stock": inventory_info.available_quantity > 0,
                        "stock_quantity": inventory_info.available_quantity,
                        "inventory_status": inventory_info.status.value,
                        "market_availability": {
                            market_id: inventory_info.status != InventoryStatus.OUT_OF_STOCK
                        },
                        "low_stock_warning": inventory_info.status == InventoryStatus.LOW_STOCK,
                        "estimated_restock": inventory_info.estimated_restock_date,
                        "inventory_last_updated": inventory_info.last_updated
                    })
                    
                    enriched_products.append(enriched_product)
                else:
                    # Producto sin informaci√≥n de inventario - usar fallback
                    enriched_product = product.copy()
                    enriched_product.update({
                        "availability": "available",  # Optimistic fallback
                        "in_stock": True,
                        "stock_quantity": 10,  # Cantidad placeholder
                        "inventory_status": "available",
                        "market_availability": {market_id: True},
                        "low_stock_warning": False,
                        "estimated_restock": None,
                        "inventory_last_updated": time.time()
                    })
                    enriched_products.append(enriched_product)
            
            logger.info(f"‚úÖ Enriched {len(enriched_products)} products with inventory data")
            return enriched_products
            
        except Exception as e:
            logger.error(f"Error enriching products with inventory: {e}")
            # Retornar productos originales si falla el enriquecimiento
            return products
    
    async def _get_cached_inventory(self, product_id: str, market_id: str) -> Optional[InventoryInfo]:
        """Obtener informaci√≥n de inventario desde cache"""
        if not self.redis:
            return None
            
        try:
            cache_key = f"{self.CACHE_PREFIX}:{product_id}:{market_id}"
            cached_data = await self.redis.get(cache_key)
            
            if cached_data:
                data = json.loads(cached_data)
                return InventoryInfo(
                    product_id=data["product_id"],
                    status=InventoryStatus(data["status"]),
                    quantity=data["quantity"],
                    reserved_quantity=data.get("reserved_quantity", 0),
                    available_quantity=data.get("available_quantity", 0),
                    low_stock_threshold=data.get("low_stock_threshold", 5),
                    market_availability=data.get("market_availability", {}),
                    supplier_info=data.get("supplier_info", {}),
                    last_updated=data.get("last_updated", time.time()),
                    estimated_restock_date=data.get("estimated_restock_date")
                )
        except Exception as e:
            logger.warning(f"Error reading inventory cache: {e}")
        
        return None
    
    async def _cache_inventory_info(self, inventory_info: InventoryInfo, market_id: str):
        """Cachear informaci√≥n de inventario"""
        if not self.redis:
            return
            
        try:
            cache_key = f"{self.CACHE_PREFIX}:{inventory_info.product_id}:{market_id}"
            cache_data = {
                "product_id": inventory_info.product_id,
                "status": inventory_info.status.value,
                "quantity": inventory_info.quantity,
                "reserved_quantity": inventory_info.reserved_quantity,
                "available_quantity": inventory_info.available_quantity,
                "low_stock_threshold": inventory_info.low_stock_threshold,
                "market_availability": inventory_info.market_availability,
                "supplier_info": inventory_info.supplier_info,
                "last_updated": inventory_info.last_updated,
                "estimated_restock_date": inventory_info.estimated_restock_date
            }
            
            await self.redis.setex(cache_key, self.CACHE_TTL, json.dumps(cache_data))
            
        except Exception as e:
            logger.warning(f"Error caching inventory info: {e}")
    
    async def _get_shopify_inventory(self, product_id: str) -> Dict[str, Any]:
        """Obtener datos de inventario desde Shopify"""
        try:
            if not self.shopify_client:
                self.shopify_client = get_shopify_client()
            
            if not self.shopify_client:
                logger.warning("Shopify client not available")
                return {}
            
            # Intentar obtener informaci√≥n de inventario de Shopify
            # Nota: Esta implementaci√≥n depende de la API espec√≠fica de Shopify
            product_data = await self._fetch_shopify_product(product_id)
            
            if product_data:
                # Extraer informaci√≥n de inventario de la respuesta de Shopify
                inventory_data = {
                    "quantity": product_data.get("inventory_quantity", 0),
                    "tracked": product_data.get("inventory_tracked", True),
                    "policy": product_data.get("inventory_policy", "deny"),
                    "available": product_data.get("available", True)
                }
                
                return inventory_data
            
        except Exception as e:
            logger.warning(f"Error fetching Shopify inventory for {product_id}: {e}")
        
        return {}
    
    async def _fetch_shopify_product(self, product_id: str) -> Optional[Dict]:
        """Obtener producto desde Shopify de manera async-safe"""
        try:
            # Esta es una implementaci√≥n simulada
            # En producci√≥n, esto se conectar√≠a a la API real de Shopify
            
            # Simulaci√≥n de datos de Shopify
            simulated_data = {
                "id": product_id,
                "inventory_quantity": 15,  # Cantidad simulada
                "inventory_tracked": True,
                "inventory_policy": "deny",
                "available": True
            }
            
            # A√±adir algo de variabilidad para testing
            import random
            simulated_data["inventory_quantity"] = random.randint(0, 50)
            simulated_data["available"] = simulated_data["inventory_quantity"] > 0
            
            return simulated_data
            
        except Exception as e:
            logger.warning(f"Error in Shopify product fetch simulation: {e}")
            return None
    
    async def _build_inventory_info(
        self, 
        product_id: str, 
        market_id: str, 
        shopify_data: Dict[str, Any]
    ) -> InventoryInfo:
        """Construir InventoryInfo a partir de datos de Shopify"""
        
        # Obtener configuraci√≥n del mercado
        market_config = self.market_configs.get(market_id, self.market_configs["US"])
        
        # Extraer cantidad de Shopify
        quantity = shopify_data.get("quantity", 0)
        if quantity == 0 and shopify_data.get("available", True):
            # Si Shopify dice que est√° disponible pero no hay cantidad, asumir stock bajo
            quantity = 3
        
        # Construir informaci√≥n de inventario
        inventory_info = InventoryInfo(
            product_id=product_id,
            status=InventoryStatus.AVAILABLE,  # Se calcular√° en __post_init__
            quantity=quantity,
            reserved_quantity=0,  # Podr√≠a obtenerse de Shopify en implementaci√≥n real
            low_stock_threshold=market_config["low_stock_threshold"],
            market_availability={
                market_id: quantity > 0 and shopify_data.get("available", True)
            },
            supplier_info={
                "shopify_tracked": shopify_data.get("tracked", True),
                "shopify_policy": shopify_data.get("policy", "deny")
            }
        )
        
        return inventory_info
    
    async def _create_fallback_inventory(self, product_id: str, market_id: str) -> InventoryInfo:
        """Crear informaci√≥n de inventario de fallback optimista"""
        
        market_config = self.market_configs.get(market_id, self.market_configs["US"])
        
        # Fallback optimista - asumir disponibilidad
        fallback_info = InventoryInfo(
            product_id=product_id,
            status=InventoryStatus.AVAILABLE,
            quantity=15,  # Cantidad optimista
            reserved_quantity=0,
            low_stock_threshold=market_config["low_stock_threshold"],
            market_availability={market_id: market_config["default_availability"]},
            supplier_info={"source": "fallback", "optimistic": True}
        )
        
        # Cachear fallback por menos tiempo
        if self.redis:
            try:
                cache_key = f"{self.CACHE_PREFIX}:fallback:{product_id}:{market_id}"
                cache_data = {
                    "product_id": product_id,
                    "status": fallback_info.status.value,
                    "quantity": fallback_info.quantity,
                    "market_availability": fallback_info.market_availability,
                    "fallback": True,
                    "created_at": time.time()
                }
                await self.redis.setex(cache_key, self.FALLBACK_TTL, json.dumps(cache_data))
            except Exception as e:
                logger.warning(f"Error caching fallback inventory: {e}")
        
        logger.info(f"üîÑ Created fallback inventory for {product_id} in market {market_id}")
        return fallback_info
    
    def get_market_availability_summary(self, products_inventory: Dict[str, InventoryInfo]) -> Dict[str, Any]:
        """Generar resumen de disponibilidad por mercado"""
        
        summary = {
            "total_products": len(products_inventory),
            "available_products": 0,
            "low_stock_products": 0,
            "out_of_stock_products": 0,
            "availability_rate": 0.0,
            "avg_stock_level": 0.0,
            "products_by_status": {status.value: 0 for status in InventoryStatus}
        }
        
        if not products_inventory:
            return summary
        
        total_stock = 0
        for inventory_info in products_inventory.values():
            status = inventory_info.status
            summary["products_by_status"][status.value] += 1
            
            if status == InventoryStatus.AVAILABLE:
                summary["available_products"] += 1
            elif status == InventoryStatus.LOW_STOCK:
                summary["low_stock_products"] += 1
            elif status == InventoryStatus.OUT_OF_STOCK:
                summary["out_of_stock_products"] += 1
            
            total_stock += inventory_info.available_quantity
        
        # Calcular m√©tricas
        summary["availability_rate"] = (summary["available_products"] + summary["low_stock_products"]) / summary["total_products"]
        summary["avg_stock_level"] = total_stock / summary["total_products"]
        
        return summary

# Factory function para crear instancia del servicio
def create_inventory_service(redis_client: Optional[RedisClient] = None) -> InventoryService:
    """Factory para crear InventoryService"""
    return InventoryService(redis_client=redis_client)
